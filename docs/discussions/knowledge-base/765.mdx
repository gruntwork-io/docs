---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/765" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>What is the recommended folder structure for Terragrunt?</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84AVR_V","number":765,"author":{"login":"brikis98"},"title":"What is the recommended folder structure for Terragrunt?","body":"\r\nWe got a series of questions from a customer:\r\n\r\n1. One repo for infra-live and one for infra-modules, or combine them?\r\n1. One Terraform config for an entire environment, or split out by resource?\r\n1. Whether to use one branch per environment, or a single branch with all environments?\r\n1. How to handle global variables?\r\n1. How to set up the backend (e.g., S3 bucket)?\r\n1. How to connect Terraform configuration to the backend (e.g., S3 state files)? \r\n1. How to handle module defaults?\r\n1. How to handle tagging?\r\n\r\nThese questions come up often, so I'll post our recommendations below.\r\n\r\n---\r\n\r\n<ins datetime=\"2023-08-31T12:07:32Z\">\r\n  <p><a href=\"https://support.gruntwork.io/hc/requests/110425\">Tracked in ticket #110425</a></p>\r\n</ins>\r\n","bodyHTML":"<p dir=\"auto\">We got a series of questions from a customer:</p>\n<ol dir=\"auto\">\n<li>One repo for infra-live and one for infra-modules, or combine them?</li>\n<li>One Terraform config for an entire environment, or split out by resource?</li>\n<li>Whether to use one branch per environment, or a single branch with all environments?</li>\n<li>How to handle global variables?</li>\n<li>How to set up the backend (e.g., S3 bucket)?</li>\n<li>How to connect Terraform configuration to the backend (e.g., S3 state files)?</li>\n<li>How to handle module defaults?</li>\n<li>How to handle tagging?</li>\n</ol>\n<p dir=\"auto\">These questions come up often, so I'll post our recommendations below.</p>\n<hr>\n<ins datetime=\"2023-08-31T12:07:32Z\">\n  <p dir=\"auto\"><a href=\"https://support.gruntwork.io/hc/requests/110425\" rel=\"nofollow\">Tracked in ticket #110425</a></p>\n</ins>","answer":{"body":"# One repo for infra-live and one for infra-modules, or combine them?\r\n\r\nWe recommend separate repos. The primary reason is so you can version your modules and run different versions of those modules in different environments: e.g., you might run `v1.0.0` of your `eks` module in `prod` while testing out `v2.0.0` of the `eks` module in `stage`. As described in [module versioning](https://blog.gruntwork.io/how-to-create-reusable-infrastructure-with-terraform-modules-25526d65f73d#b9d8):\r\n\r\n> The easiest way to create a versioned module is to put the code for the module in a separate Git repository and to set the source parameter to that repository’s URL. That means your Terraform code will be spread out across (at least) two repositories:\r\n>\r\n> - **modules**: This repo defines reusable modules. Think of each module as a “blueprint” that defines a specific part of your infrastructure.\r\n> - **live**: This repo defines the live infrastructure you’re running in each environment (stage, prod, mgmt, etc.). Think of this as the “houses” you built from the “blueprints” in the modules repo.\r\n\r\n[See here](https://github.com/gruntwork-io/terragrunt-infrastructure-live-example#how-is-the-code-in-this-repo-organized) for how to lay out your `infra-live` repo. And [see here](https://terragrunt.gruntwork.io/docs/features/keep-your-terraform-code-dry/) for how, in `infra-live`, to deploy your modules from `infra-modules`.\r\n\r\n# One Terraform config for an entire environment, or split out by resource?\r\n\r\nGenerally speaking, you want to keep Terraform modules small. Bigger modules are slower (e.g., `plan` can take 10+ minutes), harder to understand (reading 1,000 lines of `plan` output is hard), less secure (you need broad permissions to make any change), more risky (the blast radius for mistakes is huge), and so on (see [large modules considered harmful](https://blog.gruntwork.io/5-lessons-learned-from-writing-over-300-000-lines-of-infrastructure-code-36ba7fadeac1#302b)). Putting all the code for an entire environment in a single module is very likely to result in a large module, so we strongly recommend breaking things down into smaller pieces.\r\n\r\nThat said, those pieces shouldn't be too small; you wouldn't want to do a single module per resource. You need to find a good balance, grouping things that are typically deployed together, have similar deployment cadences, have similar risk/security profiles, have common team ownership, etc. So, for example, you might have one module that handles all your networking; another module that sets up your data stores (e.g., RDS); another module that handles your orchestration tool (e.g., EKS); and perhaps a bunch of individual modules to deploy apps, each owned by a separate team. [See the answer here for more info](https://github.com/orgs/gruntwork-io/discussions/402#discussioncomment-2681334).\r\n\r\n# Whether to use one branch per environment, or a single branch with all environments?\r\n\r\nWe recommend a single branch for all environments, but with versioned modules everywhere, so different environments can deploy different versions. See [How to manage multiple environments with Terraform](https://blog.gruntwork.io/how-to-manage-multiple-environments-with-terraform-32c7bc5d692) for a comparison of Terraform workspaces, branches, and the Terragrunt approaches (we, of course, recommend the [Terragrunt approach](https://blog.gruntwork.io/how-to-manage-multiple-environments-with-terraform-using-terragrunt-2c3e32fc60a8)).\r\n\r\n# How to handle global variables?\r\n\r\nTypically, you have a _hierarchy_ of variables: some that are truly global across all accounts/environments; some that apply across a single account/environment; some that apply across a single region; some that apply across a set of services; etc. \r\n\r\nThere are multiple ways to handle this, depending on the use case, but the most common pattern is:\r\n\r\n1. See [here](https://github.com/gruntwork-io/terragrunt-infrastructure-live-example#how-is-the-code-in-this-repo-organized) for how to lay out your folder structure in `infra-live` to capture this hierarchy.\r\n2. Put reusable variables at the right \"level\" within that hierarchy in a `.hcl` file: e.g., `account.hcl`, `region.hcl`, `networking.hcl`, etc.\r\n3. Use [`read_terragrunt_config`](https://terragrunt.gruntwork.io/docs/reference/built-in-functions/#read_terragrunt_config) and [`find_in_parent_folders`](https://terragrunt.gruntwork.io/docs/reference/built-in-functions/#find_in_parent_folders) to automatically load the data from the file from the appropriate place in the hierarchy.\r\n\r\nFor more details and the other options, see [Keep your Terragrunt Architecture DRY](https://terragrunt.gruntwork.io/docs/features/keep-your-terragrunt-architecture-dry/).\r\n\r\n# How to set up the backend (e.g., S3 bucket)?\r\n\r\nSee [How should I create the backend (e.g., S3 bucket) for storing Terraform state?](https://github.com/orgs/gruntwork-io/discussions/769).\r\n\r\n# How to connect Terraform configuration to the backend (e.g., S3 state files)?\r\n\r\n[See the tutorial here](https://terragrunt.gruntwork.io/docs/features/keep-your-remote-state-configuration-dry/). This will allow you to define your `backend` configuration in a single place so all your state files are stored in S3 in a folder hierarchy that matches the folder hierarchy of the modules themselves: e.g., the state for `prod/us-east-1/networking/vpc/terragrunt.hcl` will automatically be stored at `prod/us-east-1/networking/vpc/terraform.tfstate` in your S3 bucket.\r\n\r\n# How to handle module defaults?\r\n\r\n1. Create Terraform modules in `infra-modules` that set reasonable `default` values for all input variables.\r\n2. When deploying those modules in `infra-live`, you get those defaults automatically, but you can also override them on a per-environment basis if necessary.\r\n\r\n# How to handle tagging?\r\n\r\nSee [how do I enforce tagging using Terragrunt](https://github.com/orgs/gruntwork-io/discussions/756).","bodyHTML":"<h1 dir=\"auto\">One repo for infra-live and one for infra-modules, or combine them?</h1>\n<p dir=\"auto\">We recommend separate repos. The primary reason is so you can version your modules and run different versions of those modules in different environments: e.g., you might run <code class=\"notranslate\">v1.0.0</code> of your <code class=\"notranslate\">eks</code> module in <code class=\"notranslate\">prod</code> while testing out <code class=\"notranslate\">v2.0.0</code> of the <code class=\"notranslate\">eks</code> module in <code class=\"notranslate\">stage</code>. As described in <a href=\"https://blog.gruntwork.io/how-to-create-reusable-infrastructure-with-terraform-modules-25526d65f73d#b9d8\" rel=\"nofollow\">module versioning</a>:</p>\n<blockquote>\n<p dir=\"auto\">The easiest way to create a versioned module is to put the code for the module in a separate Git repository and to set the source parameter to that repository’s URL. That means your Terraform code will be spread out across (at least) two repositories:</p>\n<ul dir=\"auto\">\n<li><strong>modules</strong>: This repo defines reusable modules. Think of each module as a “blueprint” that defines a specific part of your infrastructure.</li>\n<li><strong>live</strong>: This repo defines the live infrastructure you’re running in each environment (stage, prod, mgmt, etc.). Think of this as the “houses” you built from the “blueprints” in the modules repo.</li>\n</ul>\n</blockquote>\n<p dir=\"auto\"><a href=\"https://github.com/gruntwork-io/terragrunt-infrastructure-live-example#how-is-the-code-in-this-repo-organized\">See here</a> for how to lay out your <code class=\"notranslate\">infra-live</code> repo. And <a href=\"https://terragrunt.gruntwork.io/docs/features/keep-your-terraform-code-dry/\" rel=\"nofollow\">see here</a> for how, in <code class=\"notranslate\">infra-live</code>, to deploy your modules from <code class=\"notranslate\">infra-modules</code>.</p>\n<h1 dir=\"auto\">One Terraform config for an entire environment, or split out by resource?</h1>\n<p dir=\"auto\">Generally speaking, you want to keep Terraform modules small. Bigger modules are slower (e.g., <code class=\"notranslate\">plan</code> can take 10+ minutes), harder to understand (reading 1,000 lines of <code class=\"notranslate\">plan</code> output is hard), less secure (you need broad permissions to make any change), more risky (the blast radius for mistakes is huge), and so on (see <a href=\"https://blog.gruntwork.io/5-lessons-learned-from-writing-over-300-000-lines-of-infrastructure-code-36ba7fadeac1#302b\" rel=\"nofollow\">large modules considered harmful</a>). Putting all the code for an entire environment in a single module is very likely to result in a large module, so we strongly recommend breaking things down into smaller pieces.</p>\n<p dir=\"auto\">That said, those pieces shouldn't be too small; you wouldn't want to do a single module per resource. You need to find a good balance, grouping things that are typically deployed together, have similar deployment cadences, have similar risk/security profiles, have common team ownership, etc. So, for example, you might have one module that handles all your networking; another module that sets up your data stores (e.g., RDS); another module that handles your orchestration tool (e.g., EKS); and perhaps a bunch of individual modules to deploy apps, each owned by a separate team. <a href=\"https://github.com/orgs/gruntwork-io/discussions/402#discussioncomment-2681334\">See the answer here for more info</a>.</p>\n<h1 dir=\"auto\">Whether to use one branch per environment, or a single branch with all environments?</h1>\n<p dir=\"auto\">We recommend a single branch for all environments, but with versioned modules everywhere, so different environments can deploy different versions. See <a href=\"https://blog.gruntwork.io/how-to-manage-multiple-environments-with-terraform-32c7bc5d692\" rel=\"nofollow\">How to manage multiple environments with Terraform</a> for a comparison of Terraform workspaces, branches, and the Terragrunt approaches (we, of course, recommend the <a href=\"https://blog.gruntwork.io/how-to-manage-multiple-environments-with-terraform-using-terragrunt-2c3e32fc60a8\" rel=\"nofollow\">Terragrunt approach</a>).</p>\n<h1 dir=\"auto\">How to handle global variables?</h1>\n<p dir=\"auto\">Typically, you have a <em>hierarchy</em> of variables: some that are truly global across all accounts/environments; some that apply across a single account/environment; some that apply across a single region; some that apply across a set of services; etc.</p>\n<p dir=\"auto\">There are multiple ways to handle this, depending on the use case, but the most common pattern is:</p>\n<ol dir=\"auto\">\n<li>See <a href=\"https://github.com/gruntwork-io/terragrunt-infrastructure-live-example#how-is-the-code-in-this-repo-organized\">here</a> for how to lay out your folder structure in <code class=\"notranslate\">infra-live</code> to capture this hierarchy.</li>\n<li>Put reusable variables at the right \"level\" within that hierarchy in a <code class=\"notranslate\">.hcl</code> file: e.g., <code class=\"notranslate\">account.hcl</code>, <code class=\"notranslate\">region.hcl</code>, <code class=\"notranslate\">networking.hcl</code>, etc.</li>\n<li>Use <a href=\"https://terragrunt.gruntwork.io/docs/reference/built-in-functions/#read_terragrunt_config\" rel=\"nofollow\"><code class=\"notranslate\">read_terragrunt_config</code></a> and <a href=\"https://terragrunt.gruntwork.io/docs/reference/built-in-functions/#find_in_parent_folders\" rel=\"nofollow\"><code class=\"notranslate\">find_in_parent_folders</code></a> to automatically load the data from the file from the appropriate place in the hierarchy.</li>\n</ol>\n<p dir=\"auto\">For more details and the other options, see <a href=\"https://terragrunt.gruntwork.io/docs/features/keep-your-terragrunt-architecture-dry/\" rel=\"nofollow\">Keep your Terragrunt Architecture DRY</a>.</p>\n<h1 dir=\"auto\">How to set up the backend (e.g., S3 bucket)?</h1>\n<p dir=\"auto\">See <a href=\"https://github.com/orgs/gruntwork-io/discussions/769\">How should I create the backend (e.g., S3 bucket) for storing Terraform state?</a>.</p>\n<h1 dir=\"auto\">How to connect Terraform configuration to the backend (e.g., S3 state files)?</h1>\n<p dir=\"auto\"><a href=\"https://terragrunt.gruntwork.io/docs/features/keep-your-remote-state-configuration-dry/\" rel=\"nofollow\">See the tutorial here</a>. This will allow you to define your <code class=\"notranslate\">backend</code> configuration in a single place so all your state files are stored in S3 in a folder hierarchy that matches the folder hierarchy of the modules themselves: e.g., the state for <code class=\"notranslate\">prod/us-east-1/networking/vpc/terragrunt.hcl</code> will automatically be stored at <code class=\"notranslate\">prod/us-east-1/networking/vpc/terraform.tfstate</code> in your S3 bucket.</p>\n<h1 dir=\"auto\">How to handle module defaults?</h1>\n<ol dir=\"auto\">\n<li>Create Terraform modules in <code class=\"notranslate\">infra-modules</code> that set reasonable <code class=\"notranslate\">default</code> values for all input variables.</li>\n<li>When deploying those modules in <code class=\"notranslate\">infra-live</code>, you get those defaults automatically, but you can also override them on a per-environment basis if necessary.</li>\n</ol>\n<h1 dir=\"auto\">How to handle tagging?</h1>\n<p dir=\"auto\">See <a href=\"https://github.com/orgs/gruntwork-io/discussions/756\">how do I enforce tagging using Terragrunt</a>.</p>"}}} />

</CenterLayout>
  

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "4e3b979d57159a11d2b417d6f31acd49"
}
##DOCS-SOURCER-END -->
