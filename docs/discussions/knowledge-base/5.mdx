---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/5" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>In the Reference Architecture, why is there an ECS Deploy Runner in each account? Is this DRY?</h1>
<GitHub discussion={{"id":"MDEwOkRpc2N1c3Npb24zNTM5MjI1","number":5,"author":{"login":"zackproser"},"title":"In the Reference Architecture, why is there an ECS Deploy Runner in each account? Is this DRY?","body":"A customer asked if having an `ecs-deploy-runner` in each account is a violation of the DRY (don't repeat yourself) principle: \r\n\r\n> This is kind of an abstract, strategy question but here goes. With our refarch, we have a number of DRY violations (in particular, ecs-deploy-runner s in each account). Is it generally advisable to identify these things, then introduce a higher-level module (i.e. by wrapping the Gruntwork one) with all the commonality to reduce the size of the leaf terragrunt.hcl files?","bodyHTML":"<p dir=\"auto\">A customer asked if having an <code class=\"notranslate\">ecs-deploy-runner</code> in each account is a violation of the DRY (don't repeat yourself) principle:</p>\n<blockquote>\n<p dir=\"auto\">This is kind of an abstract, strategy question but here goes. With our refarch, we have a number of DRY violations (in particular, ecs-deploy-runner s in each account). Is it generally advisable to identify these things, then introduce a higher-level module (i.e. by wrapping the Gruntwork one) with all the commonality to reduce the size of the leaf terragrunt.hcl files?</p>\n</blockquote>","answer":{"body":"## Having one ECS Deploy Runner in each account is intended\r\n\r\nThe ECS Deploy Runner (EDR or `ecs-deploy-runner`) actually has two purposes: \r\n1. During the Ref Arch deployment, performed by a Gruntwork engineer, the EDR is intentionally spun up in each account. Once up, it is the responsibility of the EDR to run `terragrunt  run-all apply` on that particular account's infrastructure-live folder (e.g., `dev`) in order to provision the resources defined in the scaffolded code. So, it's the EDR that is actually responsible for deploying the generated code that defined a Ref Arch\r\n2. Once the Ref Arch is handed off, the EDR intentionally remains in each account because it is what runs the CI/CD operations (running `terragrunt plan` when you push a feature branch, or `terragrunt apply` when you merge to main) and it is a core component of what makes our product unique. \r\n\r\n## EDR is concerned with locking down CI/CD operations for enhanced security\r\n\r\nIn a traditional infrastructure CI/CD setup, you are bound to give unlimited admin privileges to the CI server so that it can deploy arbitrary infrastructure. However, this has many risks, the primary one being a user with write access can open a PR that does malicious things in the CI pipeline by editing the CI config. For example, a user could modify one of the steps in `.circleci/config.yml` to run the command `env`, which would dump all environment variables to `stdout`. (However it appears that CircleCI is smart enough to obfuscate credentials which are defined as Environment Variables in the Project Settings.)\r\n\r\nTo protect against this, the `ecs-deploy-runner` employs a limited action model, where the AWS credentials provided to the CI server is only allowed to trigger specific actions, one of them being running `terraform apply` on the latest infra code.\r\n\r\n## DRYing up EDR configurations\r\n\r\nBy nature, the `ecs-deploy-runner` is a commodity in that there isn’t much difference between all the accounts. The biggest difference is actually in the `shared` account, where the `ecs-deploy-runner` is configured to also build docker images and AMIs. However, outside of that all the other app accounts have the exact same `ecs-deploy-runner` configuration.\r\n\r\nIn that regard, DRY-ing up the configurations that are currently nearly identical across accounts would reduce complexity by making it less likely to forget to update all the `ecs-deploy-runner`s.\r\n\r\nThat said, the challenge is DRY-ing up the configuration in a satisfactory way that doesn’t inadvertently introduce some other bug. \r\n\r\nFor what it's worth, we are really close to offering something better in the `imports` feature: https://github.com/gruntwork-io/terragrunt/issues/1566","bodyHTML":"<h2 dir=\"auto\">Having one ECS Deploy Runner in each account is intended</h2>\n<p dir=\"auto\">The ECS Deploy Runner (EDR or <code class=\"notranslate\">ecs-deploy-runner</code>) actually has two purposes:</p>\n<ol dir=\"auto\">\n<li>During the Ref Arch deployment, performed by a Gruntwork engineer, the EDR is intentionally spun up in each account. Once up, it is the responsibility of the EDR to run <code class=\"notranslate\">terragrunt  run-all apply</code> on that particular account's infrastructure-live folder (e.g., <code class=\"notranslate\">dev</code>) in order to provision the resources defined in the scaffolded code. So, it's the EDR that is actually responsible for deploying the generated code that defined a Ref Arch</li>\n<li>Once the Ref Arch is handed off, the EDR intentionally remains in each account because it is what runs the CI/CD operations (running <code class=\"notranslate\">terragrunt plan</code> when you push a feature branch, or <code class=\"notranslate\">terragrunt apply</code> when you merge to main) and it is a core component of what makes our product unique.</li>\n</ol>\n<h2 dir=\"auto\">EDR is concerned with locking down CI/CD operations for enhanced security</h2>\n<p dir=\"auto\">In a traditional infrastructure CI/CD setup, you are bound to give unlimited admin privileges to the CI server so that it can deploy arbitrary infrastructure. However, this has many risks, the primary one being a user with write access can open a PR that does malicious things in the CI pipeline by editing the CI config. For example, a user could modify one of the steps in <code class=\"notranslate\">.circleci/config.yml</code> to run the command <code class=\"notranslate\">env</code>, which would dump all environment variables to <code class=\"notranslate\">stdout</code>. (However it appears that CircleCI is smart enough to obfuscate credentials which are defined as Environment Variables in the Project Settings.)</p>\n<p dir=\"auto\">To protect against this, the <code class=\"notranslate\">ecs-deploy-runner</code> employs a limited action model, where the AWS credentials provided to the CI server is only allowed to trigger specific actions, one of them being running <code class=\"notranslate\">terraform apply</code> on the latest infra code.</p>\n<h2 dir=\"auto\">DRYing up EDR configurations</h2>\n<p dir=\"auto\">By nature, the <code class=\"notranslate\">ecs-deploy-runner</code> is a commodity in that there isn’t much difference between all the accounts. The biggest difference is actually in the <code class=\"notranslate\">shared</code> account, where the <code class=\"notranslate\">ecs-deploy-runner</code> is configured to also build docker images and AMIs. However, outside of that all the other app accounts have the exact same <code class=\"notranslate\">ecs-deploy-runner</code> configuration.</p>\n<p dir=\"auto\">In that regard, DRY-ing up the configurations that are currently nearly identical across accounts would reduce complexity by making it less likely to forget to update all the <code class=\"notranslate\">ecs-deploy-runner</code>s.</p>\n<p dir=\"auto\">That said, the challenge is DRY-ing up the configuration in a satisfactory way that doesn’t inadvertently introduce some other bug.</p>\n<p dir=\"auto\">For what it's worth, we are really close to offering something better in the <code class=\"notranslate\">imports</code> feature: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"817724989\" data-permission-text=\"Title is private\" data-url=\"https://github.com/gruntwork-io/terragrunt/issues/1566\" data-hovercard-type=\"issue\" data-hovercard-url=\"/gruntwork-io/terragrunt/issues/1566/hovercard\" href=\"https://github.com/gruntwork-io/terragrunt/issues/1566\">gruntwork-io/terragrunt#1566</a></p>"}}} />

</CenterLayout>

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "6ef7f6771071325fde3f97726a281e34"
}
##DOCS-SOURCER-END -->
