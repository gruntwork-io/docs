---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/355" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>TERRAGRUNT_IAM_ROLE with S3 backend</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84APSaN","number":355,"author":null,"title":"TERRAGRUNT_IAM_ROLE with S3 backend","body":"We are running into an issue when using TERRAGRUNT_IAM_ROLE. Our configuration is as follows:\r\n\r\n1. Use AWS SSO to access Account A.\r\n2. Run Terragrunt with TERRAGRUNT_IAM_ROLE to assume role A in account A.\r\n3. In the Terraform provider config we assume role B in Account B with rights to deploy resources into Account B.\r\n4. In the Terraform backend config we assume role C in Account C with rights to an S3 bucket and DynamoDB table.\r\n\r\nIf we use this configuration we get an error similar to:\r\n\r\nAccessDenied: User: arn:aws:sts::XXXXXXXX:assumed-role/AWSReservedSSO_XXXXXXXX_XXXXXXXX/example@example.com is not authorized to perform: sts:AssumeRole on resource: arn:aws:iam::ACCOUNT C:role/RoleC\r\n\r\nIn our understanding Terragrunt should be assuming Role A and Role A then has the rights to assume Role C in Account C. This does not seem to be the case.\r\n\r\nIf we amend the configuration and grant the SSO role access to Role C then everything works.\r\n\r\nIs this expected behaviour or should Role A be used by Terragrunt to access Role C as defined in the backend config?\r\n\r\nBelow is a refactored config for our backend and provider in Terragrunt.\r\n\r\n```hcl\r\ngenerate \"provider\" {\r\n  path      = \"provider.tf\"\r\n  if_exists = \"overwrite_terragrunt\"\r\n  contents  = <<EOF\r\nprovider \"aws\" {\r\n  region = \"region\"\r\n  allowed_account_ids = [\"ACCOUNT B\"]\r\n\r\n  assume_role {\r\n    role_arn = \"arn:aws:iam::ACCOUNT B:role/RoleB\"\r\n  }\r\n}\r\nEOF\r\n}\r\n\r\nremote_state {\r\n  backend = \"s3\"\r\n  config = {\r\n    skip_bucket_versioning         = true\r\n    encrypt = true\r\n    bucket  = \"bucket\"\r\n    key     = \"terraform.tfstate\"\r\n    region  = \"region\"\r\n    dynamodb_table = \"table\"\r\n    kms_key_id = \"key_id\"\r\n    role_arn = \"arn:aws:iam::ACCOUNT C:role/RoleC\"\r\n  }\r\n  generate = {\r\n    path      = \"backend.tf\"\r\n    if_exists = \"overwrite_terragrunt\"\r\n  }\r\n}\r\n```\r\nr:terragrunt","bodyHTML":"<p dir=\"auto\">We are running into an issue when using TERRAGRUNT_IAM_ROLE. Our configuration is as follows:</p>\n<ol dir=\"auto\">\n<li>Use AWS SSO to access Account A.</li>\n<li>Run Terragrunt with TERRAGRUNT_IAM_ROLE to assume role A in account A.</li>\n<li>In the Terraform provider config we assume role B in Account B with rights to deploy resources into Account B.</li>\n<li>In the Terraform backend config we assume role C in Account C with rights to an S3 bucket and DynamoDB table.</li>\n</ol>\n<p dir=\"auto\">If we use this configuration we get an error similar to:</p>\n<p dir=\"auto\">AccessDenied: User: arn:aws:sts::XXXXXXXX:assumed-role/AWSReservedSSO_XXXXXXXX_XXXXXXXX/<a href=\"mailto:example@example.com\">example@example.com</a> is not authorized to perform: sts:AssumeRole on resource: arn:aws:iam::ACCOUNT C:role/RoleC</p>\n<p dir=\"auto\">In our understanding Terragrunt should be assuming Role A and Role A then has the rights to assume Role C in Account C. This does not seem to be the case.</p>\n<p dir=\"auto\">If we amend the configuration and grant the SSO role access to Role C then everything works.</p>\n<p dir=\"auto\">Is this expected behaviour or should Role A be used by Terragrunt to access Role C as defined in the backend config?</p>\n<p dir=\"auto\">Below is a refactored config for our backend and provider in Terragrunt.</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"generate &quot;provider&quot; {\n  path      = &quot;provider.tf&quot;\n  if_exists = &quot;overwrite_terragrunt&quot;\n  contents  = &lt;&lt;EOF\nprovider &quot;aws&quot; {\n  region = &quot;region&quot;\n  allowed_account_ids = [&quot;ACCOUNT B&quot;]\n\n  assume_role {\n    role_arn = &quot;arn:aws:iam::ACCOUNT B:role/RoleB&quot;\n  }\n}\nEOF\n}\n\nremote_state {\n  backend = &quot;s3&quot;\n  config = {\n    skip_bucket_versioning         = true\n    encrypt = true\n    bucket  = &quot;bucket&quot;\n    key     = &quot;terraform.tfstate&quot;\n    region  = &quot;region&quot;\n    dynamodb_table = &quot;table&quot;\n    kms_key_id = &quot;key_id&quot;\n    role_arn = &quot;arn:aws:iam::ACCOUNT C:role/RoleC&quot;\n  }\n  generate = {\n    path      = &quot;backend.tf&quot;\n    if_exists = &quot;overwrite_terragrunt&quot;\n  }\n}\"><pre class=\"notranslate\"><span class=\"pl-en\">generate</span> <span class=\"pl-smi\">\"provider\"</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">path</span>      <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>provider.tf<span class=\"pl-pds\">\"</span></span>\n  <span class=\"pl-v\"><span class=\"pl-smi\">if_exists</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>overwrite_terragrunt<span class=\"pl-pds\">\"</span></span>\n  <span class=\"pl-v\"><span class=\"pl-smi\">contents</span>  <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-k\">&lt;&lt;</span><span class=\"pl-k\">EOF</span></span>\n<span class=\"pl-s\">provider \"aws\" {</span>\n<span class=\"pl-s\">  region = \"region\"</span>\n<span class=\"pl-s\">  allowed_account_ids = [\"ACCOUNT B\"]</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">  assume_role {</span>\n<span class=\"pl-s\">    role_arn = \"arn:aws:iam::ACCOUNT B:role/RoleB\"</span>\n<span class=\"pl-s\">  }</span>\n<span class=\"pl-s\">}</span>\n<span class=\"pl-s\"><span class=\"pl-k\">EOF</span></span>\n}\n\n<span class=\"pl-en\">remote_state</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">backend</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>s3<span class=\"pl-pds\">\"</span></span>\n  <span class=\"pl-v\"><span class=\"pl-smi\">config</span> <span class=\"pl-k\">=</span> </span>{\n    skip_bucket_versioning         <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>\n    encrypt <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>\n    bucket  <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>bucket<span class=\"pl-pds\">\"</span></span>\n    key     <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>terraform.tfstate<span class=\"pl-pds\">\"</span></span>\n    region  <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>region<span class=\"pl-pds\">\"</span></span>\n    dynamodb_table <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>table<span class=\"pl-pds\">\"</span></span>\n    kms_key_id <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>key_id<span class=\"pl-pds\">\"</span></span>\n    role_arn <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>arn:aws:iam::ACCOUNT C:role/RoleC<span class=\"pl-pds\">\"</span></span>\n  }\n  <span class=\"pl-v\"><span class=\"pl-smi\">generate</span> <span class=\"pl-k\">=</span> </span>{\n    path      <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>backend.tf<span class=\"pl-pds\">\"</span></span>\n    if_exists <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>overwrite_terragrunt<span class=\"pl-pds\">\"</span></span>\n  }\n}</pre></div>\n<p dir=\"auto\">r:terragrunt</p>","answer":{"body":"`TERRAGRUNT_IAM_ROLE` does not support role chaining at the moment for internal AWS operations. In this case, Terragrunt does not chain the assume role call between the IAM role specified in `TERRAGRUNT_IAM_ROLE`, and the IAM role specified in `role_arn` config specified on the `remote_state` block when it makes the calls internally. Instead, it will directly assume the role specified in `role_arn` (ignoring `TERRAGRUNT_IAM_ROLE`). Note that it will use `TERRAGRUNT_IAM_ROLE` if `role_arn` isn't specified (which is admittedly confusing).\r\n\r\nDespite this limitation, this works for the provider config, because the role chaining (second assume role) happens in `terraform`, not `terragrunt`.\r\n\r\nTo be transparent, the IAM role assume rules in Terragrunt is a bit of a mess right now because of the complexities around AWS session management. As such, unless there is a specific need for having terragrunt assume the role (e.g., for use cases around cross account dependencies), we typically recommend using an external tool like `aws-vault` to do the role assume.\r\n\r\nWe have plans in our roadmap to revamp the AWS authentication strategy within Terragrunt. You can follow [this GitHub issue](https://github.com/gruntwork-io/terragrunt/issues/1840) for updates on this rework when we prioritize it.","bodyHTML":"<p dir=\"auto\"><code class=\"notranslate\">TERRAGRUNT_IAM_ROLE</code> does not support role chaining at the moment for internal AWS operations. In this case, Terragrunt does not chain the assume role call between the IAM role specified in <code class=\"notranslate\">TERRAGRUNT_IAM_ROLE</code>, and the IAM role specified in <code class=\"notranslate\">role_arn</code> config specified on the <code class=\"notranslate\">remote_state</code> block when it makes the calls internally. Instead, it will directly assume the role specified in <code class=\"notranslate\">role_arn</code> (ignoring <code class=\"notranslate\">TERRAGRUNT_IAM_ROLE</code>). Note that it will use <code class=\"notranslate\">TERRAGRUNT_IAM_ROLE</code> if <code class=\"notranslate\">role_arn</code> isn't specified (which is admittedly confusing).</p>\n<p dir=\"auto\">Despite this limitation, this works for the provider config, because the role chaining (second assume role) happens in <code class=\"notranslate\">terraform</code>, not <code class=\"notranslate\">terragrunt</code>.</p>\n<p dir=\"auto\">To be transparent, the IAM role assume rules in Terragrunt is a bit of a mess right now because of the complexities around AWS session management. As such, unless there is a specific need for having terragrunt assume the role (e.g., for use cases around cross account dependencies), we typically recommend using an external tool like <code class=\"notranslate\">aws-vault</code> to do the role assume.</p>\n<p dir=\"auto\">We have plans in our roadmap to revamp the AWS authentication strategy within Terragrunt. You can follow <a href=\"https://github.com/gruntwork-io/terragrunt/issues/1840\" data-hovercard-type=\"issue\" data-hovercard-url=\"/gruntwork-io/terragrunt/issues/1840/hovercard\">this GitHub issue</a> for updates on this rework when we prioritize it.</p>"}}} />

</CenterLayout>

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "39f3eb741edfbd9de24363d6823d73b0"
}
##DOCS-SOURCER-END -->
