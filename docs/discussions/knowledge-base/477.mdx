---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>Passing variable from child to parent terragrunt.hcl</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84AP2Kv","number":477,"author":{"login":"nwmcsween"},"title":"Passing variable from child to parent terragrunt.hcl","body":"\r\nI'm using yamldecode with templatefile and need to pass dependency outputs in the child as possible inputs to templatefile and was wondering what the easiest way of doing this would be?\r\n\r\nparent.hcl locals:\r\n```hcl\r\nlocals {\r\n  parent_dir            = get_parent_terragrunt_dir()\r\n  child_path            = path_relative_to_include()                                       # test/foo--mod or test/mod.\r\n  child_path_components = compact(split(\"/\", local.child_path))                            # test, foo--mod or test, mod.\r\n  child_module          = reverse(split(\"--\", reverse(local.child_path_components)[0]))[0] # mod\r\n  possible_value_paths = [\r\n    for i in range(0, length(local.child_path_components) + 1) :\r\n    join(\"/\", concat(\r\n      [local.parent_dir],\r\n      slice(local.child_path_components, 0, i),\r\n      [\"values.yaml\"]\r\n    ))\r\n  ]\r\n  raw_values = [\r\n    for path in local.possible_value_paths :\r\n    yamldecode(file(path)) if fileexists(path)\r\n  ]\r\n  values = [\r\n    for path in local.possible_value_paths :\r\n     # Terraform doesn't provide a templatestring function thus we need to yamldecode() twice.\r\n    yamldecode(templatefile(path, local.raw_values)) if fileexists(path) # Parent templates can't reference child templates as they won't be templated.\r\n  ]\r\n\r\n  # TODO: get child dependency outputs somehow so yaml files can reference them.\r\n}\r\n```\r\n\r\n---\r\n\r\n<ins datetime=\"2022-06-17T17:44:33Z\">\r\n  <p><a href=\"https://support.gruntwork.io/hc/requests/108804\">Tracked in ticket #108804</a></p>\r\n</ins>\r\n","bodyHTML":"<p dir=\"auto\">I'm using yamldecode with templatefile and need to pass dependency outputs in the child as possible inputs to templatefile and was wondering what the easiest way of doing this would be?</p>\n<p dir=\"auto\">parent.hcl locals:</p>\n<div class=\"highlight highlight-source-terraform notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"locals {\n  parent_dir            = get_parent_terragrunt_dir()\n  child_path            = path_relative_to_include()                                       # test/foo--mod or test/mod.\n  child_path_components = compact(split(&quot;/&quot;, local.child_path))                            # test, foo--mod or test, mod.\n  child_module          = reverse(split(&quot;--&quot;, reverse(local.child_path_components)[0]))[0] # mod\n  possible_value_paths = [\n    for i in range(0, length(local.child_path_components) + 1) :\n    join(&quot;/&quot;, concat(\n      [local.parent_dir],\n      slice(local.child_path_components, 0, i),\n      [&quot;values.yaml&quot;]\n    ))\n  ]\n  raw_values = [\n    for path in local.possible_value_paths :\n    yamldecode(file(path)) if fileexists(path)\n  ]\n  values = [\n    for path in local.possible_value_paths :\n     # Terraform doesn't provide a templatestring function thus we need to yamldecode() twice.\n    yamldecode(templatefile(path, local.raw_values)) if fileexists(path) # Parent templates can't reference child templates as they won't be templated.\n  ]\n\n  # TODO: get child dependency outputs somehow so yaml files can reference them.\n}\"><pre><span class=\"pl-k\">locals</span> {\n  parent_dir            <span class=\"pl-k\">=</span> <span class=\"pl-v\">get_parent_terragrunt_dir</span>()\n  child_path            <span class=\"pl-k\">=</span> <span class=\"pl-v\">path_relative_to_include</span>()                                       <span class=\"pl-c\"><span class=\"pl-c\">#</span> test/foo--mod or test/mod.</span>\n  child_path_components <span class=\"pl-k\">=</span> <span class=\"pl-c1\">compact</span>(<span class=\"pl-c1\">split</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">child_path</span>))                            <span class=\"pl-c\"><span class=\"pl-c\">#</span> test, foo--mod or test, mod.</span>\n  child_module          <span class=\"pl-k\">=</span> <span class=\"pl-c1\">reverse</span>(<span class=\"pl-c1\">split</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>--<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">reverse</span>(<span class=\"pl-c1\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">child_path_components</span>)[<span class=\"pl-c1\">0</span>]))[<span class=\"pl-c1\">0</span>] <span class=\"pl-c\"><span class=\"pl-c\">#</span> mod</span>\n  possible_value_paths <span class=\"pl-k\">=</span> [\n    <span class=\"pl-k\">for</span> <span class=\"pl-smi\">i</span> <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">length</span>(<span class=\"pl-c1\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">child_path_components</span>) <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>) <span class=\"pl-k\">:</span>\n    <span class=\"pl-c1\">join</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">concat</span>(\n      [<span class=\"pl-c1\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">parent_dir</span>],\n      <span class=\"pl-c1\">slice</span>(<span class=\"pl-c1\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">child_path_components</span>, <span class=\"pl-c1\">0</span>, i),\n      [<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>values.yaml<span class=\"pl-pds\">\"</span></span>]\n    ))\n  ]\n  raw_values <span class=\"pl-k\">=</span> [\n    <span class=\"pl-k\">for</span> <span class=\"pl-c1\">path</span> <span class=\"pl-k\">in</span> <span class=\"pl-c1\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">possible_value_paths</span> <span class=\"pl-k\">:</span>\n    <span class=\"pl-c1\">yamldecode</span>(<span class=\"pl-c1\">file</span>(<span class=\"pl-c1\">path</span>)) <span class=\"pl-k\">if</span> <span class=\"pl-c1\">fileexists</span>(<span class=\"pl-c1\">path</span>)\n  ]\n  values <span class=\"pl-k\">=</span> [\n    <span class=\"pl-k\">for</span> <span class=\"pl-c1\">path</span> <span class=\"pl-k\">in</span> <span class=\"pl-c1\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">possible_value_paths</span> <span class=\"pl-k\">:</span>\n     <span class=\"pl-c\"><span class=\"pl-c\">#</span> Terraform doesn't provide a templatestring function thus we need to yamldecode() twice.</span>\n    <span class=\"pl-c1\">yamldecode</span>(<span class=\"pl-c1\">templatefile</span>(<span class=\"pl-c1\">path</span>, <span class=\"pl-c1\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">raw_values</span>)) <span class=\"pl-k\">if</span> <span class=\"pl-c1\">fileexists</span>(<span class=\"pl-c1\">path</span>) <span class=\"pl-c\"><span class=\"pl-c\">#</span> Parent templates can't reference child templates as they won't be templated.</span>\n  ]\n\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> TODO: get child dependency outputs somehow so yaml files can reference them.</span>\n}</pre></div>\n<hr>\n<ins datetime=\"2022-06-17T17:44:33Z\">\n  <p dir=\"auto\"><a href=\"https://support.gruntwork.io/hc/requests/108804\" rel=\"nofollow\">Tracked in ticket #108804</a></p>\n</ins>","answer":{"body":"You can't reference dependencies in locals due to [a limitation in terragrunt parsing logic](https://terragrunt.gruntwork.io/docs/getting-started/configuration/#configuration-parsing-order). However, you can kind of do what you want by taking advantage of the fact that `terragrunt` uses environment variables to pass terraform variables, and thus checks on `inputs` are more relaxed.\r\n\r\nSee [this blog post](https://blog.gruntwork.io/even-more-dry-and-maintainable-code-with-terragrunt-5738d1ffc1c9), and more specifically [this section](https://blog.gruntwork.io/even-more-dry-and-maintainable-code-with-terragrunt-5738d1ffc1c9#f9bc).","bodyHTML":"<p dir=\"auto\">You can't reference dependencies in locals due to <a href=\"https://terragrunt.gruntwork.io/docs/getting-started/configuration/#configuration-parsing-order\" rel=\"nofollow\">a limitation in terragrunt parsing logic</a>. However, you can kind of do what you want by taking advantage of the fact that <code class=\"notranslate\">terragrunt</code> uses environment variables to pass terraform variables, and thus checks on <code class=\"notranslate\">inputs</code> are more relaxed.</p>\n<p dir=\"auto\">See <a href=\"https://blog.gruntwork.io/even-more-dry-and-maintainable-code-with-terragrunt-5738d1ffc1c9\" rel=\"nofollow\">this blog post</a>, and more specifically <a href=\"https://blog.gruntwork.io/even-more-dry-and-maintainable-code-with-terragrunt-5738d1ffc1c9#f9bc\" rel=\"nofollow\">this section</a>.</p>"}}} />

</CenterLayout>
  

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "03a88ec4f8c81cbf461a6a5de66816a5"
}
##DOCS-SOURCER-END -->
