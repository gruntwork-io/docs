---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>How do you update multiple module versions and apply them all at once?</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84AOax8","number":112,"author":{"login":"marijakstrazdas"},"title":"How do you update multiple module versions and apply them all at once?","body":"A customer asked: \r\n\r\n> How do you update multiple module versions and apply them all at once? For example, there’s a module deployed in 10 different accounts that you’d like to update. How do you (a) modify the version number in all 10 terragrunt.hcl files, and (b) apply the updates to all files in a single Pull Request / CI job?","bodyHTML":"<p dir=\"auto\">A customer asked:</p>\n<blockquote>\n<p dir=\"auto\">How do you update multiple module versions and apply them all at once? For example, there’s a module deployed in 10 different accounts that you’d like to update. How do you (a) modify the version number in all 10 terragrunt.hcl files, and (b) apply the updates to all files in a single Pull Request / CI job?</p>\n</blockquote>","answer":{"body":"Gruntwork Pipelines simplifies the deployment model when managing architectures deployed across multiple AWS accounts. Gruntwork Pipelines comes configured out of the box with each new Gruntwork Reference Architecture deployment. \r\n\r\nWhen you push a feature branch with changes to the `dev` environment and open a Pull Request, for example, a terragrunt `plan` is generated for you to review while Pipelines implements a hold for manual approval. You can review and discuss the pull request with your team. \r\n\r\nOnce the pull request with the changes is merged, Gruntwork Pipelines will run a `terragrunt apply` to deploy your infrastructure changes. \r\n\r\nNote that when you wish to update multiple accounts, we recommend leveraging the `DeployOrder` attribute for your accounts. [See the documentation for `DeployOrder` here.](https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/docs/06-adding-a-new-account.md#set-the-deploy-order). \r\n\r\n`DeployOrder` allows you to specify which account's changes should be done first when handling multiple account updates. For example, you may wish to have your internal `dev` and `sandbox` accounts deployed first as canaries - so that any unexpected fallout is constrained to your internal environments. You might then promote your release candidate to staging and finally to prod, assuming all acceptance tests pass. \r\n\r\nFor example, suppose you have the following folder structure:\r\n```bash\r\n.\r\n├── accounts.json\r\n├── _envcommon\r\n│   └── services\r\n│       └── my-app.hcl\r\n├── dev\r\n│   └── us-east-1\r\n│       └── dev\r\n│           └── services\r\n│               └── my-app\r\n│                   └── terragrunt.hcl\r\n│\r\n├── stage\r\n│   └── us-east-1\r\n│       └── stage\r\n│           └── services\r\n│               └── my-app\r\n│                   └── terragrunt.hcl\r\n└── prod\r\n    └── us-east-1\r\n        └── prod\r\n            └── services\r\n                └── my-app\r\n                    └── terragrunt.hcl\r\n```\r\nAnd suppose you had the following in your accounts.json file:\r\n```javascript\r\n{\r\n  \"logs\": {\r\n    \"deploy_order\": 5,\r\n    \"id\": \"111111111111\",\r\n    \"root_user_email\": \"\"\r\n  },\r\n  \"security\": {\r\n    \"deploy_order\": 5,\r\n    \"id\": \"222222222222\",\r\n    \"root_user_email\": \"\"\r\n  },\r\n  \"shared\": {\r\n    \"deploy_order\": 4,\r\n    \"id\": \"333333333333\",\r\n    \"root_user_email\": \"\"\r\n  },\r\n  \"dev\": {\r\n    \"deploy_order\": 1,\r\n    \"id\": \"444444444444\",\r\n    \"root_user_email\": \"\"\r\n  },\r\n  \"stage\": {\r\n    \"deploy_order\": 2,\r\n    \"id\": \"555555555555\",\r\n    \"root_user_email\": \"\"\r\n  },\r\n  \"prod\": {\r\n    \"deploy_order\": 3,\r\n    \"id\": \"666666666666\",\r\n    \"root_user_email\": \"\"\r\n  }\r\n}\r\n```\r\nIf you make a change in _envcommon/services/my-app.hcl, then the Infrastructure CI/CD pipeline will proceed to run plan and apply in the deploy order specified in the accounts.json file. For the example, this means that the pipeline will run plan and apply on dev first, then stage, and then finally prod. If anything fails in between, then the pipeline will halt at that point. That is, if there is an error trying to deploy to dev, then the pipeline will halt without moving to stage or prod.\r\n\r\nUsing Gruntwork Pipelines and its `DeployOrder` functionality, you can orchestrate complex multi-account deployments in a sane way that leverages familiar pull request workflows your team is already comfortable with.","bodyHTML":"<p dir=\"auto\">Gruntwork Pipelines simplifies the deployment model when managing architectures deployed across multiple AWS accounts. Gruntwork Pipelines comes configured out of the box with each new Gruntwork Reference Architecture deployment.</p>\n<p dir=\"auto\">When you push a feature branch with changes to the <code class=\"notranslate\">dev</code> environment and open a Pull Request, for example, a terragrunt <code class=\"notranslate\">plan</code> is generated for you to review while Pipelines implements a hold for manual approval. You can review and discuss the pull request with your team.</p>\n<p dir=\"auto\">Once the pull request with the changes is merged, Gruntwork Pipelines will run a <code class=\"notranslate\">terragrunt apply</code> to deploy your infrastructure changes.</p>\n<p dir=\"auto\">Note that when you wish to update multiple accounts, we recommend leveraging the <code class=\"notranslate\">DeployOrder</code> attribute for your accounts. <a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/docs/06-adding-a-new-account.md#set-the-deploy-order\">See the documentation for <code class=\"notranslate\">DeployOrder</code> here.</a>.</p>\n<p dir=\"auto\"><code class=\"notranslate\">DeployOrder</code> allows you to specify which account's changes should be done first when handling multiple account updates. For example, you may wish to have your internal <code class=\"notranslate\">dev</code> and <code class=\"notranslate\">sandbox</code> accounts deployed first as canaries - so that any unexpected fallout is constrained to your internal environments. You might then promote your release candidate to staging and finally to prod, assuming all acceptance tests pass.</p>\n<p dir=\"auto\">For example, suppose you have the following folder structure:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\".\n├── accounts.json\n├── _envcommon\n│   └── services\n│       └── my-app.hcl\n├── dev\n│   └── us-east-1\n│       └── dev\n│           └── services\n│               └── my-app\n│                   └── terragrunt.hcl\n│\n├── stage\n│   └── us-east-1\n│       └── stage\n│           └── services\n│               └── my-app\n│                   └── terragrunt.hcl\n└── prod\n    └── us-east-1\n        └── prod\n            └── services\n                └── my-app\n                    └── terragrunt.hcl\"><pre><span class=\"pl-c1\">.</span>\n├── accounts.json\n├── _envcommon\n│   └── services\n│       └── my-app.hcl\n├── dev\n│   └── us-east-1\n│       └── dev\n│           └── services\n│               └── my-app\n│                   └── terragrunt.hcl\n│\n├── stage\n│   └── us-east-1\n│       └── stage\n│           └── services\n│               └── my-app\n│                   └── terragrunt.hcl\n└── prod\n    └── us-east-1\n        └── prod\n            └── services\n                └── my-app\n                    └── terragrunt.hcl</pre></div>\n<p dir=\"auto\">And suppose you had the following in your accounts.json file:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{\n  &quot;logs&quot;: {\n    &quot;deploy_order&quot;: 5,\n    &quot;id&quot;: &quot;111111111111&quot;,\n    &quot;root_user_email&quot;: &quot;&quot;\n  },\n  &quot;security&quot;: {\n    &quot;deploy_order&quot;: 5,\n    &quot;id&quot;: &quot;222222222222&quot;,\n    &quot;root_user_email&quot;: &quot;&quot;\n  },\n  &quot;shared&quot;: {\n    &quot;deploy_order&quot;: 4,\n    &quot;id&quot;: &quot;333333333333&quot;,\n    &quot;root_user_email&quot;: &quot;&quot;\n  },\n  &quot;dev&quot;: {\n    &quot;deploy_order&quot;: 1,\n    &quot;id&quot;: &quot;444444444444&quot;,\n    &quot;root_user_email&quot;: &quot;&quot;\n  },\n  &quot;stage&quot;: {\n    &quot;deploy_order&quot;: 2,\n    &quot;id&quot;: &quot;555555555555&quot;,\n    &quot;root_user_email&quot;: &quot;&quot;\n  },\n  &quot;prod&quot;: {\n    &quot;deploy_order&quot;: 3,\n    &quot;id&quot;: &quot;666666666666&quot;,\n    &quot;root_user_email&quot;: &quot;&quot;\n  }\n}\"><pre><span class=\"pl-kos\">{</span>\n  <span class=\"pl-s\">\"logs\"</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"deploy_order\"</span>: <span class=\"pl-c1\">5</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"id\"</span>: <span class=\"pl-s\">\"111111111111\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"root_user_email\"</span>: <span class=\"pl-s\">\"\"</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">\"security\"</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"deploy_order\"</span>: <span class=\"pl-c1\">5</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"id\"</span>: <span class=\"pl-s\">\"222222222222\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"root_user_email\"</span>: <span class=\"pl-s\">\"\"</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">\"shared\"</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"deploy_order\"</span>: <span class=\"pl-c1\">4</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"id\"</span>: <span class=\"pl-s\">\"333333333333\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"root_user_email\"</span>: <span class=\"pl-s\">\"\"</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">\"dev\"</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"deploy_order\"</span>: <span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"id\"</span>: <span class=\"pl-s\">\"444444444444\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"root_user_email\"</span>: <span class=\"pl-s\">\"\"</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">\"stage\"</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"deploy_order\"</span>: <span class=\"pl-c1\">2</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"id\"</span>: <span class=\"pl-s\">\"555555555555\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"root_user_email\"</span>: <span class=\"pl-s\">\"\"</span>\n  <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">\"prod\"</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"deploy_order\"</span>: <span class=\"pl-c1\">3</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"id\"</span>: <span class=\"pl-s\">\"666666666666\"</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-s\">\"root_user_email\"</span>: <span class=\"pl-s\">\"\"</span>\n  <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">If you make a change in _envcommon/services/my-app.hcl, then the Infrastructure CI/CD pipeline will proceed to run plan and apply in the deploy order specified in the accounts.json file. For the example, this means that the pipeline will run plan and apply on dev first, then stage, and then finally prod. If anything fails in between, then the pipeline will halt at that point. That is, if there is an error trying to deploy to dev, then the pipeline will halt without moving to stage or prod.</p>\n<p dir=\"auto\">Using Gruntwork Pipelines and its <code class=\"notranslate\">DeployOrder</code> functionality, you can orchestrate complex multi-account deployments in a sane way that leverages familiar pull request workflows your team is already comfortable with.</p>"}}} />

</CenterLayout>
  

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "a05eaed18c363ff69f174db7db154a43"
}
##DOCS-SOURCER-END -->
