---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/473" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>How to handle large plan outputs in Gruntwork Pipeline?</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84AP1YF","number":473,"author":{"login":"yorinasub17"},"title":"How to handle large plan outputs in Gruntwork Pipeline?","body":"\nFrom my understanding Gruntwork Pipelines posts the results/stdout from Terragrunt/Terraform plan/apply into the PR comments. How does this work for very large/long plans and builds?\r\n\r\nAlso, using your example of deploying CloudFront which could take 1 hour, how do we know that the Gruntwork pipeline runner is actually “doing” something and not just dead or hanging? Are the results/stdout streamed into the PR comments as chunks or would we have to wait for a hour after its deployed to actually see the comments in the PR comment section?\n\n---\n\n<ins datetime=\"2022-06-16T14:47:01Z\">\n  <p><a href=\"https://support.gruntwork.io/hc/requests/108789\">Tracked in ticket #108789</a></p>\n</ins>\n","bodyHTML":"<p dir=\"auto\">From my understanding Gruntwork Pipelines posts the results/stdout from Terragrunt/Terraform plan/apply into the PR comments. How does this work for very large/long plans and builds?</p>\n<p dir=\"auto\">Also, using your example of deploying CloudFront which could take 1 hour, how do we know that the Gruntwork pipeline runner is actually “doing” something and not just dead or hanging? Are the results/stdout streamed into the PR comments as chunks or would we have to wait for a hour after its deployed to actually see the comments in the PR comment section?</p>\n<hr>\n<ins datetime=\"2022-06-16T14:47:01Z\">\n  <p dir=\"auto\"><a href=\"https://support.gruntwork.io/hc/requests/108789\" rel=\"nofollow\">Tracked in ticket #108789</a></p>\n</ins>","answer":{"body":"First, Gruntwork Pipeline actually doesn’t really post the plan outputs into PR comments. In the default mode, it is assumed to be running in a synchronous call, and streams the results back to the `infrastructure-deployer` CLI that is making the call to it, so it can work just like directly calling terragrunt apply. In this case, you will need to add additional logic in the GitHub Actions to post the results on the PR itself.\r\n\r\nHowever, it can also be made to run in the background asynchronously (with the `--no-wait` flag on `infrastructure-deployer`), and post the output in S3. In this mode, the typical way to string it together is to:\r\n\r\n- Have GitHub Actions create a check suite that tracks the deployment on the commit.\r\n- Create a GitHub Actions workflow that completes the check suite from a manual trigger.\r\n- Define a Lambda function that calls the \"complete\" workflow using an [S3 trigger](https://docs.aws.amazon.com/lambda/latest/dg/with-s3-example.html).\r\n\r\nUsing this setup, the callback from the deploy runner is managed through the S3 trigger lambda function, which will post the plan/apply results onto the commit check as details. Or alternatively, you can have the completion workflow post the results to the PR.\r\n\r\nIn async mode, the disadvantage is that you won't have a way to know the status in real time through GitHub. However, the CLI will post a link to CloudWatch Logs for the job, and you can login to AWS to retrieve the log events, provided you have an IAM user that can observe/retrieve the logs (NOTE: A user with [invoke permissions](https://github.com/gruntwork-io/terraform-aws-ci/tree/master/modules/ecs-deploy-runner-invoke-iam-policy) has this permission).","bodyHTML":"<p dir=\"auto\">First, Gruntwork Pipeline actually doesn’t really post the plan outputs into PR comments. In the default mode, it is assumed to be running in a synchronous call, and streams the results back to the <code class=\"notranslate\">infrastructure-deployer</code> CLI that is making the call to it, so it can work just like directly calling terragrunt apply. In this case, you will need to add additional logic in the GitHub Actions to post the results on the PR itself.</p>\n<p dir=\"auto\">However, it can also be made to run in the background asynchronously (with the <code class=\"notranslate\">--no-wait</code> flag on <code class=\"notranslate\">infrastructure-deployer</code>), and post the output in S3. In this mode, the typical way to string it together is to:</p>\n<ul dir=\"auto\">\n<li>Have GitHub Actions create a check suite that tracks the deployment on the commit.</li>\n<li>Create a GitHub Actions workflow that completes the check suite from a manual trigger.</li>\n<li>Define a Lambda function that calls the \"complete\" workflow using an <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/with-s3-example.html\" rel=\"nofollow\">S3 trigger</a>.</li>\n</ul>\n<p dir=\"auto\">Using this setup, the callback from the deploy runner is managed through the S3 trigger lambda function, which will post the plan/apply results onto the commit check as details. Or alternatively, you can have the completion workflow post the results to the PR.</p>\n<p dir=\"auto\">In async mode, the disadvantage is that you won't have a way to know the status in real time through GitHub. However, the CLI will post a link to CloudWatch Logs for the job, and you can login to AWS to retrieve the log events, provided you have an IAM user that can observe/retrieve the logs (NOTE: A user with <a href=\"https://github.com/gruntwork-io/terraform-aws-ci/tree/master/modules/ecs-deploy-runner-invoke-iam-policy\">invoke permissions</a> has this permission).</p>"}}} />

</CenterLayout>

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "166256ba3d966c1f0ee177f0364332a6"
}
##DOCS-SOURCER-END -->
