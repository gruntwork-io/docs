---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/416" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>How Gruntwork Pipelines works in a multi-account, multi-region model with terragrunt?</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84APhcA","number":416,"author":{"login":"chambodn"},"title":"How Gruntwork Pipelines works in a multi-account, multi-region model with terragrunt?","body":"\nHello,\r\n\r\nI am trying to understand how the gruntwork pipelines framework will interact with an AWS multi-account, multi-region topology. \r\nWe are using `terragrunt` to manage our infrastructure similar to the one you provide in the [infrastructure-live folder](https://github.com/gruntwork-io/terraform-aws-service-catalog/tree/master/examples/for-production/infrastructure-live) of your terraform-aws-service-catalog repository. \r\nWe created a new Shared AWS Account to deploy the secrets required to communicate with our VCS. Based on the diagram [here](https://docs.gruntwork.io/assets/images/landing-zone-ref-arch-08ff1641db41e41a0ad9d50c34a4a61b.png), I concluded that the \"terraform/terragrunt executors\" (i.e., `ecs-deploy-runner` tasks in `ECS`) should be deployed in all the AWS Accounts (dev, prod, security, etc...) for all regions (using multi-region modules as defined [here](https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_envcommon/mgmt/ecs-deploy-runner.hcl#L38-L60)). \r\n\r\n> Note: The VPC Management part, though, as a [dependency](https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_envcommon/mgmt/ecs-deploy-runner.hcl#L24-L32) to this multi-region module and therefore still need to be deployed in all the regions.\r\n\r\nThis decentralized model sounds great but leads me to some questions.\r\n\r\nConsidering that we have the live repository with `terragrunt` to represent our entire infrastructure, I wondered how the CI server would identify which `lambda invoker` function / `ecs-deploy-runner` (in which region, which account)? In our case, we plan to use GitLab and the OIDC integration to avoid storing secrets. How can I know in advance which IAM role (allowing me to invoke the lambda) I need to assume to invoke the lambda invoker?\r\n\r\nLet's say we have the following structure:\r\n```bash\r\n.\r\n└── live\r\n    ├── sandbox-account-backend # <---- Where my microservices are *deployed*\r\n    │   ├── _global\r\n    │   │   └── iam\r\n    │   ├── eu-west-1\r\n    │   │   ├── eks\r\n    │   │   └── mgmt\r\n    │   │       ├── ecs-deploy-runner # <---- My multi-region module for this account\r\n    │   │       └── networking\r\n    │   │           └── vpc\r\n    │   └── eu-west-3\r\n    │       ├── eks\r\n    │       └── mgmt\r\n    │           └── networking # <---- Still needed as we don't have a \"multi-region\" module for VPC Mgmt \r\n    │               └── vpc\r\n    ├── sandbox-account-networking\r\n    │   ├── _global\r\n    │   │   ├── dns\r\n    │   │   └── iam\r\n    │   ├── eu-west-1\r\n    │   │   ├── apigateway # <---- Where my microservices are *exposed*\r\n    │   │   └── mgmt\r\n    │   │       ├── ecs-deploy-runner\r\n    │   │       └── networking\r\n    │   │           └── vpc\r\n    │   └── eu-west-3\r\n    │       ├── apigateway\r\n    │       └── mgmt\r\n    │           └── networking\r\n    │               └── vpc\r\n    └── shared\r\n        └── eu-west-1\r\n            ├── _regional\r\n            │   └── ecr-repos\r\n            └── mgmt\r\n                ├── ecs-deploy-runner\r\n                └── networking\r\n```\r\n\r\nLet's consider I create a new PR modifying the EKS cluster in `live/sandbox-account-backend/eu-west-1/eks` and the associated apigateway in the networking account in `live/sandbox-account-networking/eu-west-1/apigateway`.\r\n\r\nWhich `ecs-deploy-runner` task will be called by GitLab CI? And if we have a cross-account dependency (e.g., apigateway depends on eks), how can we ensure the (cross-account) order will be insured?\n\n---\n\n<ins datetime=\"2022-05-12T11:51:35Z\">\n  <p><a href=\"https://support.gruntwork.io/hc/requests/108582\">Tracked in ticket #108582</a></p>\n</ins>\n","bodyHTML":"<p dir=\"auto\">Hello,</p>\n<p dir=\"auto\">I am trying to understand how the gruntwork pipelines framework will interact with an AWS multi-account, multi-region topology.<br>\nWe are using <code class=\"notranslate\">terragrunt</code> to manage our infrastructure similar to the one you provide in the <a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/tree/master/examples/for-production/infrastructure-live\">infrastructure-live folder</a> of your terraform-aws-service-catalog repository.<br>\nWe created a new Shared AWS Account to deploy the secrets required to communicate with our VCS. Based on the diagram <a href=\"https://docs.gruntwork.io/assets/images/landing-zone-ref-arch-08ff1641db41e41a0ad9d50c34a4a61b.png\" rel=\"nofollow\">here</a>, I concluded that the \"terraform/terragrunt executors\" (i.e., <code class=\"notranslate\">ecs-deploy-runner</code> tasks in <code class=\"notranslate\">ECS</code>) should be deployed in all the AWS Accounts (dev, prod, security, etc...) for all regions (using multi-region modules as defined <a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_envcommon/mgmt/ecs-deploy-runner.hcl#L38-L60\">here</a>).</p>\n<blockquote>\n<p dir=\"auto\">Note: The VPC Management part, though, as a <a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_envcommon/mgmt/ecs-deploy-runner.hcl#L24-L32\">dependency</a> to this multi-region module and therefore still need to be deployed in all the regions.</p>\n</blockquote>\n<p dir=\"auto\">This decentralized model sounds great but leads me to some questions.</p>\n<p dir=\"auto\">Considering that we have the live repository with <code class=\"notranslate\">terragrunt</code> to represent our entire infrastructure, I wondered how the CI server would identify which <code class=\"notranslate\">lambda invoker</code> function / <code class=\"notranslate\">ecs-deploy-runner</code> (in which region, which account)? In our case, we plan to use GitLab and the OIDC integration to avoid storing secrets. How can I know in advance which IAM role (allowing me to invoke the lambda) I need to assume to invoke the lambda invoker?</p>\n<p dir=\"auto\">Let's say we have the following structure:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\".\n└── live\n    ├── sandbox-account-backend # &lt;---- Where my microservices are *deployed*\n    │   ├── _global\n    │   │   └── iam\n    │   ├── eu-west-1\n    │   │   ├── eks\n    │   │   └── mgmt\n    │   │       ├── ecs-deploy-runner # &lt;---- My multi-region module for this account\n    │   │       └── networking\n    │   │           └── vpc\n    │   └── eu-west-3\n    │       ├── eks\n    │       └── mgmt\n    │           └── networking # &lt;---- Still needed as we don't have a &quot;multi-region&quot; module for VPC Mgmt \n    │               └── vpc\n    ├── sandbox-account-networking\n    │   ├── _global\n    │   │   ├── dns\n    │   │   └── iam\n    │   ├── eu-west-1\n    │   │   ├── apigateway # &lt;---- Where my microservices are *exposed*\n    │   │   └── mgmt\n    │   │       ├── ecs-deploy-runner\n    │   │       └── networking\n    │   │           └── vpc\n    │   └── eu-west-3\n    │       ├── apigateway\n    │       └── mgmt\n    │           └── networking\n    │               └── vpc\n    └── shared\n        └── eu-west-1\n            ├── _regional\n            │   └── ecr-repos\n            └── mgmt\n                ├── ecs-deploy-runner\n                └── networking\"><pre class=\"notranslate\"><span class=\"pl-c1\">.</span>\n└── live\n    ├── sandbox-account-backend <span class=\"pl-c\"><span class=\"pl-c\">#</span> &lt;---- Where my microservices are *deployed*</span>\n    │   ├── _global\n    │   │   └── iam\n    │   ├── eu-west-1\n    │   │   ├── eks\n    │   │   └── mgmt\n    │   │       ├── ecs-deploy-runner <span class=\"pl-c\"><span class=\"pl-c\">#</span> &lt;---- My multi-region module for this account</span>\n    │   │       └── networking\n    │   │           └── vpc\n    │   └── eu-west-3\n    │       ├── eks\n    │       └── mgmt\n    │           └── networking <span class=\"pl-c\"><span class=\"pl-c\">#</span> &lt;---- Still needed as we don't have a \"multi-region\" module for VPC Mgmt </span>\n    │               └── vpc\n    ├── sandbox-account-networking\n    │   ├── _global\n    │   │   ├── dns\n    │   │   └── iam\n    │   ├── eu-west-1\n    │   │   ├── apigateway <span class=\"pl-c\"><span class=\"pl-c\">#</span> &lt;---- Where my microservices are *exposed*</span>\n    │   │   └── mgmt\n    │   │       ├── ecs-deploy-runner\n    │   │       └── networking\n    │   │           └── vpc\n    │   └── eu-west-3\n    │       ├── apigateway\n    │       └── mgmt\n    │           └── networking\n    │               └── vpc\n    └── shared\n        └── eu-west-1\n            ├── _regional\n            │   └── ecr-repos\n            └── mgmt\n                ├── ecs-deploy-runner\n                └── networking</pre></div>\n<p dir=\"auto\">Let's consider I create a new PR modifying the EKS cluster in <code class=\"notranslate\">live/sandbox-account-backend/eu-west-1/eks</code> and the associated apigateway in the networking account in <code class=\"notranslate\">live/sandbox-account-networking/eu-west-1/apigateway</code>.</p>\n<p dir=\"auto\">Which <code class=\"notranslate\">ecs-deploy-runner</code> task will be called by GitLab CI? And if we have a cross-account dependency (e.g., apigateway depends on eks), how can we ensure the (cross-account) order will be insured?</p>\n<hr>\n<ins datetime=\"2022-05-12T11:51:35Z\">\n  <p dir=\"auto\"><a href=\"https://support.gruntwork.io/hc/requests/108582\" rel=\"nofollow\">Tracked in ticket #108582</a></p>\n</ins>","answer":{"body":"The primary way to handle this is by routing with a lookup table and using heuristics with the folder structure to guide you on which entry in the table to get.\r\n\r\nFor example, in the Reference Architecture, we handle this by checking for all the terragrunt folders that changed (in [this line](https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_ci/scripts/deploy-infra.sh#L105-L108)), and then for each one, extracting out [the first folder in the path](https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_ci/scripts/deploy-infra.sh#L66-L69) and using that to lookup the AWS Account ID that corresponds to the folder by matching the folder name to the entry in the accounts.json file, and then using the ID to construct the IAM Role ARN to assume and assume that (see [this function](https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_ci/scripts/helpers.sh#L10-L22)).\r\n\r\nWe are not very familiar with the GitLab OIDC integration for assuming a role, but presumably you can use similar logic to identify the IAM Role you need to assume in the workflow, and then extract that out as a step output to feed into the OIDC mechanism.\r\n\r\nHope this helps!","bodyHTML":"<p dir=\"auto\">The primary way to handle this is by routing with a lookup table and using heuristics with the folder structure to guide you on which entry in the table to get.</p>\n<p dir=\"auto\">For example, in the Reference Architecture, we handle this by checking for all the terragrunt folders that changed (in <a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_ci/scripts/deploy-infra.sh#L105-L108\">this line</a>), and then for each one, extracting out <a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_ci/scripts/deploy-infra.sh#L66-L69\">the first folder in the path</a> and using that to lookup the AWS Account ID that corresponds to the folder by matching the folder name to the entry in the accounts.json file, and then using the ID to construct the IAM Role ARN to assume and assume that (see <a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/examples/for-production/infrastructure-live/_ci/scripts/helpers.sh#L10-L22\">this function</a>).</p>\n<p dir=\"auto\">We are not very familiar with the GitLab OIDC integration for assuming a role, but presumably you can use similar logic to identify the IAM Role you need to assume in the workflow, and then extract that out as a step output to feed into the OIDC mechanism.</p>\n<p dir=\"auto\">Hope this helps!</p>"}}} />

</CenterLayout>

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "962a8799c8bf4dffe3c9510866a241ef"
}
##DOCS-SOURCER-END -->
