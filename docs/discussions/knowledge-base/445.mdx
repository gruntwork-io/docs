---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/445" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>The lifecycle of terraform plan/apply usage in CI pipelines for pull requests</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84APsls","number":445,"author":{"login":"james64"},"title":"The lifecycle of terraform plan/apply usage in CI pipelines for pull requests","body":"\nHey, I'd like to ask more general question from terraform/terragrunt world. I expect to learn something since what I was able to find on the internet kinda contradicts my everyday experience.\r\n\r\nIn the application world, on feature branch one just builds the thing, deploys it somewhere, test it, iterate, have it approved and then it's merged. Some additional testing and deploying may be done in main branch.\r\n\r\nWhen it comes to terraform code everything I was able to find talks about running `terraform plan` in PR. Only once its approved and merged to main branch, `terraform apply` is run.\r\n\r\nIn real world however, successful plan is not even near a guarantee that apply will be successful. Possible reasons for ok plan but failed apply:\r\n- Remote apis often run many custom validations\r\n  - health check interval cannot be less then 5s, resource name too long, config missing, invalid combination of settings etc etc\r\n  - sure one learns most common ones over time but with 100s of different resource types for every cloud provider this is just bound to happen even to most senior engineers\r\n- Resource cannot be created at all because some external restriction is met\r\n  - s3 bucket with this name exists, quota for number of instances in a region reached etc\r\n- Plan may be run against different state then apply\r\n  - between last plan run and merge many hours/days can pass\r\n  - unless there is always single PR being worked on at any given time\r\n- If it is first time a resource is being re-created it might error out\r\n  - dependency between resources is not configured properly (first creation is usually gradual, second one is done all by TF)\r\n  - configs like create_before_destroy might be missing\r\n\r\nIf some of these happens after a merge it means just one thing. Open another PR and continue the work. In other words **running apply is often important part** of creating the code to be merged. This already goes against what internet tells me about plan in branch and apply after merge.\r\n\r\nMy fuzzy feelings:\r\n\r\nNon production environemnts - one with low requirements for availability. One where new infra things are being tested before prod, or where dev instance of app is running and 10m of downtime is not a big deal etc\r\n- In here I would **just run apply on branch**\r\n- Locally or in ci through optional manual trigger\r\n- CI job for main branch should just check that tf plan is empty and fail otherwise\r\n- Wait but this will affect all other people working on some parallel PRs!\r\n  - Yes it will. But unless we have some very good solutions to apply issues listed above, there is not going to be any parallel infra development anyway\r\n- Wait but this leads to semi applied, possibly broken state of my infrastructure!\r\n  - Yes it does. But from infrastructure point of view it does not matter whether apply was called by ci from main branch or by me from branch. The difference is however that in branch I can iterate faster to fix stuff\r\n  - And also as pointed below I would not do this for critical environemnts\r\n\r\nBusiness critical infra - typically production\r\n- Here it is generally desired that more sets of eyes sing off a change before it is even attempted.\r\n- Also changes made here are usually already being tested in other less strict envs (by modules promotion using terragrunt for example)\r\n- Here I would go for apply only after approve/merge\r\n\r\n<hr>\r\n\r\n- Would you agree that plan-on-branch-apply-after-merge is not the sole correct way of using terra(form/grunt/mate/whatever) in CI?\r\n- Have you implemented some other approach in your company/project?\r\n- Or there is some strategy how to deal with all the issues listed at the beginning which I am missing entirelly and plan-on-branch-apply-after-merge is good fit for all after all?\r\n\r\nI hope this is not too abstract and out of scope for this discussion community. I am looking forward to learn what other people think about this :-) \n\n---\n\n<ins datetime=\"2022-06-02T07:24:18Z\">\n  <p><a href=\"https://support.gruntwork.io/hc/requests/108704\">Tracked in ticket #108704</a></p>\n</ins>\n","bodyHTML":"<p dir=\"auto\">Hey, I'd like to ask more general question from terraform/terragrunt world. I expect to learn something since what I was able to find on the internet kinda contradicts my everyday experience.</p>\n<p dir=\"auto\">In the application world, on feature branch one just builds the thing, deploys it somewhere, test it, iterate, have it approved and then it's merged. Some additional testing and deploying may be done in main branch.</p>\n<p dir=\"auto\">When it comes to terraform code everything I was able to find talks about running <code class=\"notranslate\">terraform plan</code> in PR. Only once its approved and merged to main branch, <code class=\"notranslate\">terraform apply</code> is run.</p>\n<p dir=\"auto\">In real world however, successful plan is not even near a guarantee that apply will be successful. Possible reasons for ok plan but failed apply:</p>\n<ul dir=\"auto\">\n<li>Remote apis often run many custom validations\n<ul dir=\"auto\">\n<li>health check interval cannot be less then 5s, resource name too long, config missing, invalid combination of settings etc etc</li>\n<li>sure one learns most common ones over time but with 100s of different resource types for every cloud provider this is just bound to happen even to most senior engineers</li>\n</ul>\n</li>\n<li>Resource cannot be created at all because some external restriction is met\n<ul dir=\"auto\">\n<li>s3 bucket with this name exists, quota for number of instances in a region reached etc</li>\n</ul>\n</li>\n<li>Plan may be run against different state then apply\n<ul dir=\"auto\">\n<li>between last plan run and merge many hours/days can pass</li>\n<li>unless there is always single PR being worked on at any given time</li>\n</ul>\n</li>\n<li>If it is first time a resource is being re-created it might error out\n<ul dir=\"auto\">\n<li>dependency between resources is not configured properly (first creation is usually gradual, second one is done all by TF)</li>\n<li>configs like create_before_destroy might be missing</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">If some of these happens after a merge it means just one thing. Open another PR and continue the work. In other words <strong>running apply is often important part</strong> of creating the code to be merged. This already goes against what internet tells me about plan in branch and apply after merge.</p>\n<p dir=\"auto\">My fuzzy feelings:</p>\n<p dir=\"auto\">Non production environemnts - one with low requirements for availability. One where new infra things are being tested before prod, or where dev instance of app is running and 10m of downtime is not a big deal etc</p>\n<ul dir=\"auto\">\n<li>In here I would <strong>just run apply on branch</strong></li>\n<li>Locally or in ci through optional manual trigger</li>\n<li>CI job for main branch should just check that tf plan is empty and fail otherwise</li>\n<li>Wait but this will affect all other people working on some parallel PRs!\n<ul dir=\"auto\">\n<li>Yes it will. But unless we have some very good solutions to apply issues listed above, there is not going to be any parallel infra development anyway</li>\n</ul>\n</li>\n<li>Wait but this leads to semi applied, possibly broken state of my infrastructure!\n<ul dir=\"auto\">\n<li>Yes it does. But from infrastructure point of view it does not matter whether apply was called by ci from main branch or by me from branch. The difference is however that in branch I can iterate faster to fix stuff</li>\n<li>And also as pointed below I would not do this for critical environemnts</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">Business critical infra - typically production</p>\n<ul dir=\"auto\">\n<li>Here it is generally desired that more sets of eyes sing off a change before it is even attempted.</li>\n<li>Also changes made here are usually already being tested in other less strict envs (by modules promotion using terragrunt for example)</li>\n<li>Here I would go for apply only after approve/merge</li>\n</ul>\n<hr>\n<ul dir=\"auto\">\n<li>Would you agree that plan-on-branch-apply-after-merge is not the sole correct way of using terra(form/grunt/mate/whatever) in CI?</li>\n<li>Have you implemented some other approach in your company/project?</li>\n<li>Or there is some strategy how to deal with all the issues listed at the beginning which I am missing entirelly and plan-on-branch-apply-after-merge is good fit for all after all?</li>\n</ul>\n<p dir=\"auto\">I hope this is not too abstract and out of scope for this discussion community. I am looking forward to learn what other people think about this :-)</p>\n<hr>\n<ins datetime=\"2022-06-02T07:24:18Z\">\n  <p dir=\"auto\"><a href=\"https://support.gruntwork.io/hc/requests/108704\" rel=\"nofollow\">Tracked in ticket #108704</a></p>\n</ins>","answer":{"body":"Our thoughts on this are laid out in the Core Concepts section of [this guide](https://docs.gruntwork.io/guides/build-it-yourself/pipelines/). Specifically, the relevant section starts at [Types of Infrastructure Code](https://docs.gruntwork.io/guides/build-it-yourself/pipelines/core-concepts/types-of-infrastructure-code).\r\n\r\nThe key insight here is that, as much as possible, you want to have robustly tested Infrastructure Modules that run through an apply-validate-destroy cycle to ensure the component can be deployed correctly. This can act as a tested module artifact that you can deploy with confidence into your environments by the time it gets to rolling out to the existing environments. This is similar to the \"golden image\" concept of AMIs in immutable infrastructure patterns.\r\n\r\nBasically, you should have thoroughly tested your infrastructure in sandbox environments with [automated testing](https://www.infoq.com/presentations/automated-testing-terraform-docker-packer/) even before you get to rolling it out live. Rolling out live should be more a matter of rolling out a \"golden image\" of the infra code (\"golden terraform module\").\r\n\r\nNote that although live infra config doesn't have testing, you can simulate testing by using a promotion workflow in this model. That is, you can promote the \"golden terraform module\" from `dev`, to `stage`, to `prod`, validating what's deployed along the way.","bodyHTML":"<p dir=\"auto\">Our thoughts on this are laid out in the Core Concepts section of <a href=\"https://docs.gruntwork.io/guides/build-it-yourself/pipelines/\" rel=\"nofollow\">this guide</a>. Specifically, the relevant section starts at <a href=\"https://docs.gruntwork.io/guides/build-it-yourself/pipelines/core-concepts/types-of-infrastructure-code\" rel=\"nofollow\">Types of Infrastructure Code</a>.</p>\n<p dir=\"auto\">The key insight here is that, as much as possible, you want to have robustly tested Infrastructure Modules that run through an apply-validate-destroy cycle to ensure the component can be deployed correctly. This can act as a tested module artifact that you can deploy with confidence into your environments by the time it gets to rolling out to the existing environments. This is similar to the \"golden image\" concept of AMIs in immutable infrastructure patterns.</p>\n<p dir=\"auto\">Basically, you should have thoroughly tested your infrastructure in sandbox environments with <a href=\"https://www.infoq.com/presentations/automated-testing-terraform-docker-packer/\" rel=\"nofollow\">automated testing</a> even before you get to rolling it out live. Rolling out live should be more a matter of rolling out a \"golden image\" of the infra code (\"golden terraform module\").</p>\n<p dir=\"auto\">Note that although live infra config doesn't have testing, you can simulate testing by using a promotion workflow in this model. That is, you can promote the \"golden terraform module\" from <code class=\"notranslate\">dev</code>, to <code class=\"notranslate\">stage</code>, to <code class=\"notranslate\">prod</code>, validating what's deployed along the way.</p>"}}} />

</CenterLayout>

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "b93a89b655dcbfd725d6a9e25d6673b5"
}
##DOCS-SOURCER-END -->
