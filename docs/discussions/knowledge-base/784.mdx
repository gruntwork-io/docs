---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/784" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>How do I securely give my CI server access to private Git repos?</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84AWbuW","number":784,"author":{"login":"brikis98"},"title":"How do I securely give my CI server access to private Git repos?","body":"A problem we run into constantly is the following:\r\n\r\nYou want to run some sort of automation on your code (e.g., run automated tests or `terraform apply`) on a CI server (e.g., GitHub Actions, CircleCI, etc) against repo `foo`, but that repo includes references to another _private_ Git repo `bar`. \r\n\r\n**Example 1**: you have Terraform code in repo `foo` that uses a module from repo `bar`.\r\n\r\n```hcl\r\n# foo/example/main.tf\r\nmodule \"example\" {\r\n  # A reference to private repo bar. Note this is a Git/SSH URL.\r\n  source = \"git::git@github.com:acme/bar.git//example-module\"\r\n}\r\n```\r\n\r\n**Example 2**: You have a Bash script in repo `foo` that calls `git clone` on repo `bar`.\r\n\r\n```bash\r\n# foo/example/build.sh\r\n# A reference to private repo bar. Note this is an HTTPS URL.\r\ngit clone https://github.com/acme/bar.git\r\n```\r\n\r\nAlthough most CI servers automatically give you access to the code in the repo where the build is running (e.g., `foo`), they do _not_ provide an automatic way to access code in other private repos (e.g., `bar`). \r\n\r\n**So the question is: how do you _securely_ give your CI server access to private Git repos?** \r\n\r\n- **Requirement 1: the solution must work completely non-interactively.** On your own computer, you can manually provide credentials when prompted, but on a CI server, you need an automated solution. \r\n\r\n- **Requirement 2: the solution must work with Git/SSH and HTTPS URLs.** Best practices for accessing private Git repos have changed over the years; in the past, Git/SSH URLs were typically recommended, so lots of code uses those. More recently, the tooling around HTTPS URLs has improved, and more and more code is using those.\r\n\r\n- **Requirement 3: credentials must be stored securely.** I deliberately use the term \"securely\" to indicate that this solution should _not_ involve storing credentials in an insecure manner: e.g., although you could put the credentials directly into your code (into the Git URLs used in `git clone`), storing credentials, in plain text, is _NOT_ secure:\r\n\r\n    ```bash\r\n    # foo/example/build.sh\r\n    # DO NOT DO THIS.\r\n    # Putting credentials directly in the code is NOT secure and is NOT a valid solution to this problem!\r\n    git clone https://my-username:my-secret-password@github.com/acme/bar.git\r\n    # DO NOT DO THIS.\r\n    ```\r\n\r\nSo, how do you solve this?\r\n\r\nI'll share Gruntwork's recommendation below. Feedback, suggestions, and other ideas are very welcome!\r\n\r\n---\r\n\r\n<ins datetime=\"2023-11-22T16:13:47Z\">\r\n  <p><a href=\"https://support.gruntwork.io/hc/requests/110600\">Tracked in ticket #110600</a></p>\r\n</ins>\r\n","bodyHTML":"<p dir=\"auto\">A problem we run into constantly is the following:</p>\n<p dir=\"auto\">You want to run some sort of automation on your code (e.g., run automated tests or <code class=\"notranslate\">terraform apply</code>) on a CI server (e.g., GitHub Actions, CircleCI, etc) against repo <code class=\"notranslate\">foo</code>, but that repo includes references to another <em>private</em> Git repo <code class=\"notranslate\">bar</code>.</p>\n<p dir=\"auto\"><strong>Example 1</strong>: you have Terraform code in repo <code class=\"notranslate\">foo</code> that uses a module from repo <code class=\"notranslate\">bar</code>.</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# foo/example/main.tf\nmodule &quot;example&quot; {\n  # A reference to private repo bar. Note this is a Git/SSH URL.\n  source = &quot;git::git@github.com:acme/bar.git//example-module&quot;\n}\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> foo/example/main.tf<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">module</span> <span class=\"pl-smi\">\"example\"</span> {\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> A reference to private repo bar. Note this is a Git/SSH URL.<span class=\"pl-c\"></span></span>\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git::git@github.com:acme/bar.git//example-module<span class=\"pl-pds\">\"</span></span>\n}</pre></div>\n<p dir=\"auto\"><strong>Example 2</strong>: You have a Bash script in repo <code class=\"notranslate\">foo</code> that calls <code class=\"notranslate\">git clone</code> on repo <code class=\"notranslate\">bar</code>.</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# foo/example/build.sh\n# A reference to private repo bar. Note this is an HTTPS URL.\ngit clone https://github.com/acme/bar.git\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> foo/example/build.sh</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> A reference to private repo bar. Note this is an HTTPS URL.</span>\ngit clone https://github.com/acme/bar.git</pre></div>\n<p dir=\"auto\">Although most CI servers automatically give you access to the code in the repo where the build is running (e.g., <code class=\"notranslate\">foo</code>), they do <em>not</em> provide an automatic way to access code in other private repos (e.g., <code class=\"notranslate\">bar</code>).</p>\n<p dir=\"auto\"><strong>So the question is: how do you <em>securely</em> give your CI server access to private Git repos?</strong></p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong>Requirement 1: the solution must work completely non-interactively.</strong> On your own computer, you can manually provide credentials when prompted, but on a CI server, you need an automated solution.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>Requirement 2: the solution must work with Git/SSH and HTTPS URLs.</strong> Best practices for accessing private Git repos have changed over the years; in the past, Git/SSH URLs were typically recommended, so lots of code uses those. More recently, the tooling around HTTPS URLs has improved, and more and more code is using those.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>Requirement 3: credentials must be stored securely.</strong> I deliberately use the term \"securely\" to indicate that this solution should <em>not</em> involve storing credentials in an insecure manner: e.g., although you could put the credentials directly into your code (into the Git URLs used in <code class=\"notranslate\">git clone</code>), storing credentials, in plain text, is <em>NOT</em> secure:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# foo/example/build.sh\n# DO NOT DO THIS.\n# Putting credentials directly in the code is NOT secure and is NOT a valid solution to this problem!\ngit clone https://my-username:my-secret-password@github.com/acme/bar.git\n# DO NOT DO THIS.\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> foo/example/build.sh</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> DO NOT DO THIS.</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Putting credentials directly in the code is NOT secure and is NOT a valid solution to this problem!</span>\ngit clone https://my-username:my-secret-password@github.com/acme/bar.git\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> DO NOT DO THIS.</span></pre></div>\n</li>\n</ul>\n<p dir=\"auto\">So, how do you solve this?</p>\n<p dir=\"auto\">I'll share Gruntwork's recommendation below. Feedback, suggestions, and other ideas are very welcome!</p>\n<hr>\n<ins datetime=\"2023-11-22T16:13:47Z\">\n  <p dir=\"auto\"><a href=\"https://support.gruntwork.io/hc/requests/110600\" rel=\"nofollow\">Tracked in ticket #110600</a></p>\n</ins>","answer":{"body":"Here's the approach we typically recommend. In the examples below, I'll use GitHub as the version control system and GitHub Actions as the CI server, but the same approach works with most other version control systems (e.g., GitLab, BitBucket, etc.) and CI servers (e.g., GitLab, CircleCI, etc.).\r\n\r\n1. **Create a machine user in GitHub.** A _machine user_ is a user account that isn't used by any individual person (i.e., it is _not_ your personal GitHub account); instead, it's an account owned by your company that you use specifically for automation. Using a machine user ensures that (a) if any individual person leaves your company, all your automation doesn't suddenly break when that person loses access and (b) you can share the credentials for that account with multiple people on your team, using a secret manager tool such as 1Password, so you can make changes to your automations even if one particular person happens to be OOO.\r\n\r\n2. **Grant the machine user access to the repos they need in automation.** In the example in the original question, you'll need to invite this machine user to repos `foo` (where the CI build will run) and `bar` (another private repo that contains code used in `foo`), and then, logged into GitHub as that machine user, accept those invites. \r\n\r\n3. **Create a personal access token (PAT) for the machine user.** Logged in as the machine user, create a [personal access token (PAT)](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens), and ensure that token has at least read access to the repos you need in automation: in our example, that'll be repos `foo` and `bar`. You should store this PAT in a secret manager tool such as 1Password.\r\n\r\n4. **Make the machine user username and PAT available to the CI server.** Next, you want to make the username and PAT of your machine user available to the CI build in a _secure_ manner. Most CI servers support some sort of secure way to store secrets (i.e., they are encrypted and have access controls). For example, with GitHub Actions, you can use [GitHub Actions Secrets](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions), which allow you to securely store secrets, and make them available to the build as environment variables.\r\n\r\n5. **Update your Git configuration to use your machine user credentials.** As one of the first steps in your CI / CD build, you now need to take the machine user credentials from your CI server (as environment variables) and configure Git to use use them for all `git clone` operations. We struggled for a while to get just the right \"incantation\" to support all possible types of URLs until we stumbled across [this StackOverflow post](https://stackoverflow.com/questions/73840583/script-to-set-multiple-insteadof-cases-in-gitconfig) and so here, we'll show you the configuration that finally does the right thing. \r\n\r\n    What you want is for your Git configuration (`~/.gitconfig`) to end up looking like this:\r\n\r\n    ```ini\r\n    [url \"https://<MACHINE_USER_NAME>:<MACHINE_USER_PAT>@github.com\"]\r\n      insteadOf = ssh://git@github.com\r\n      insteadOf = git@github.com\r\n      insteadOf = https://github.com\r\n    ```\r\n\r\n    Where `MACHINE_USER_NAME` is the username of your machine user and `MACHINE_USER_PAT` is the PAT for that machine user. This configuration uses [insteadOf](https://git-scm.com/docs/git-config#Documentation/git-config.txt-urlltbasegtinsteadOf) to tell Git that whenever it sees Git/SSH URLs (e.g., `ssh://git@github.com` and `git@github.com`) and HTTPS URLs (e.g., `https://github.com`), it should instead use an HTTPS URL with your machine user credentials in it. \r\n\r\n    The best way to write such a configuration into your `~/.gitconfig` is to run the `git config` command a few times. Assuming that in GitHub Actions Secrets, you used the environment variables `MACHINE_USER_NAME` and `MACHINE_USER_PAT` for the machine user name and PAT, respectively, you can run the following commands at the start of your CI build to configure Git:\r\n\r\n    ```bash\r\n    git config --global --replace-all \"url.https://$MACHINE_USER_NAME:$MACHINE_USER_PAT@github.com.insteadOf\" ssh://git@github.com\r\n    git config --global --add \"url.https://$MACHINE_USER_NAME:$MACHINE_USER_PAT@github.com.insteadOf\" git@github.com\r\n    git config --global --add \"url.https://$MACHINE_USER_NAME:$MACHINE_USER_PAT@github.com.insteadOf\" https://github.com\r\n    ```\r\n\r\n6. **Run the rest of your build!** Once you have this Git configuration in place, you can now run the rest of the build, and you'll be able to `git clone` private repos no matter how the URLs for those repos are formatted in your actual code!\r\n\r\nTry it out and let us know how it works for you!","bodyHTML":"<p dir=\"auto\">Here's the approach we typically recommend. In the examples below, I'll use GitHub as the version control system and GitHub Actions as the CI server, but the same approach works with most other version control systems (e.g., GitLab, BitBucket, etc.) and CI servers (e.g., GitLab, CircleCI, etc.).</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong>Create a machine user in GitHub.</strong> A <em>machine user</em> is a user account that isn't used by any individual person (i.e., it is <em>not</em> your personal GitHub account); instead, it's an account owned by your company that you use specifically for automation. Using a machine user ensures that (a) if any individual person leaves your company, all your automation doesn't suddenly break when that person loses access and (b) you can share the credentials for that account with multiple people on your team, using a secret manager tool such as 1Password, so you can make changes to your automations even if one particular person happens to be OOO.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>Grant the machine user access to the repos they need in automation.</strong> In the example in the original question, you'll need to invite this machine user to repos <code class=\"notranslate\">foo</code> (where the CI build will run) and <code class=\"notranslate\">bar</code> (another private repo that contains code used in <code class=\"notranslate\">foo</code>), and then, logged into GitHub as that machine user, accept those invites.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>Create a personal access token (PAT) for the machine user.</strong> Logged in as the machine user, create a <a href=\"https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens\">personal access token (PAT)</a>, and ensure that token has at least read access to the repos you need in automation: in our example, that'll be repos <code class=\"notranslate\">foo</code> and <code class=\"notranslate\">bar</code>. You should store this PAT in a secret manager tool such as 1Password.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>Make the machine user username and PAT available to the CI server.</strong> Next, you want to make the username and PAT of your machine user available to the CI build in a <em>secure</em> manner. Most CI servers support some sort of secure way to store secrets (i.e., they are encrypted and have access controls). For example, with GitHub Actions, you can use <a href=\"https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions\">GitHub Actions Secrets</a>, which allow you to securely store secrets, and make them available to the build as environment variables.</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>Update your Git configuration to use your machine user credentials.</strong> As one of the first steps in your CI / CD build, you now need to take the machine user credentials from your CI server (as environment variables) and configure Git to use use them for all <code class=\"notranslate\">git clone</code> operations. We struggled for a while to get just the right \"incantation\" to support all possible types of URLs until we stumbled across <a href=\"https://stackoverflow.com/questions/73840583/script-to-set-multiple-insteadof-cases-in-gitconfig\" rel=\"nofollow\">this StackOverflow post</a> and so here, we'll show you the configuration that finally does the right thing.</p>\n<p dir=\"auto\">What you want is for your Git configuration (<code class=\"notranslate\">~/.gitconfig</code>) to end up looking like this:</p>\n<div class=\"highlight highlight-source-ini notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"[url &quot;https://&lt;MACHINE_USER_NAME&gt;:&lt;MACHINE_USER_PAT&gt;@github.com&quot;]\n  insteadOf = ssh://git@github.com\n  insteadOf = git@github.com\n  insteadOf = https://github.com\"><pre class=\"notranslate\"><span class=\"pl-en\">[url \"https://&lt;MACHINE_USER_NAME&gt;:&lt;MACHINE_USER_PAT&gt;@github.com\"]</span>\n  <span class=\"pl-k\">insteadOf</span> = ssh://git@github.com\n  <span class=\"pl-k\">insteadOf</span> = git@github.com\n  <span class=\"pl-k\">insteadOf</span> = https://github.com</pre></div>\n<p dir=\"auto\">Where <code class=\"notranslate\">MACHINE_USER_NAME</code> is the username of your machine user and <code class=\"notranslate\">MACHINE_USER_PAT</code> is the PAT for that machine user. This configuration uses <a href=\"https://git-scm.com/docs/git-config#Documentation/git-config.txt-urlltbasegtinsteadOf\" rel=\"nofollow\">insteadOf</a> to tell Git that whenever it sees Git/SSH URLs (e.g., <code class=\"notranslate\">ssh://git@github.com</code> and <code class=\"notranslate\">git@github.com</code>) and HTTPS URLs (e.g., <code class=\"notranslate\">https://github.com</code>), it should instead use an HTTPS URL with your machine user credentials in it.</p>\n<p dir=\"auto\">The best way to write such a configuration into your <code class=\"notranslate\">~/.gitconfig</code> is to run the <code class=\"notranslate\">git config</code> command a few times. Assuming that in GitHub Actions Secrets, you used the environment variables <code class=\"notranslate\">MACHINE_USER_NAME</code> and <code class=\"notranslate\">MACHINE_USER_PAT</code> for the machine user name and PAT, respectively, you can run the following commands at the start of your CI build to configure Git:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"git config --global --replace-all &quot;url.https://$MACHINE_USER_NAME:$MACHINE_USER_PAT@github.com.insteadOf&quot; ssh://git@github.com\ngit config --global --add &quot;url.https://$MACHINE_USER_NAME:$MACHINE_USER_PAT@github.com.insteadOf&quot; git@github.com\ngit config --global --add &quot;url.https://$MACHINE_USER_NAME:$MACHINE_USER_PAT@github.com.insteadOf&quot; https://github.com\"><pre class=\"notranslate\">git config --global --replace-all <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>url.https://<span class=\"pl-smi\">$MACHINE_USER_NAME</span>:<span class=\"pl-smi\">$MACHINE_USER_PAT</span>@github.com.insteadOf<span class=\"pl-pds\">\"</span></span> ssh://git@github.com\ngit config --global --add <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>url.https://<span class=\"pl-smi\">$MACHINE_USER_NAME</span>:<span class=\"pl-smi\">$MACHINE_USER_PAT</span>@github.com.insteadOf<span class=\"pl-pds\">\"</span></span> git@github.com\ngit config --global --add <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>url.https://<span class=\"pl-smi\">$MACHINE_USER_NAME</span>:<span class=\"pl-smi\">$MACHINE_USER_PAT</span>@github.com.insteadOf<span class=\"pl-pds\">\"</span></span> https://github.com</pre></div>\n</li>\n<li>\n<p dir=\"auto\"><strong>Run the rest of your build!</strong> Once you have this Git configuration in place, you can now run the rest of the build, and you'll be able to <code class=\"notranslate\">git clone</code> private repos no matter how the URLs for those repos are formatted in your actual code!</p>\n</li>\n</ol>\n<p dir=\"auto\">Try it out and let us know how it works for you!</p>"}}} />

</CenterLayout>

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "8cb630f6c9392c016c29daa875843cd3"
}
##DOCS-SOURCER-END -->
