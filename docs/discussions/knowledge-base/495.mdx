---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/495" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>Ref Arch: How do I update the deployed Jenkins version?</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84AQBqP","number":495,"author":{"login":"zackproser"},"title":"Ref Arch: How do I update the deployed Jenkins version?","body":"\nA customer asked: \r\n> How do I update the version of Jenkins that is running in our Shared account and backing our CI/CD / GW pipelines solution? \n\n---\n\n<ins datetime=\"2022-07-07T20:03:35Z\">\n  <p><a href=\"https://support.gruntwork.io/hc/requests/108940\">Tracked in ticket #108940</a></p>\n</ins>\n","bodyHTML":"<p dir=\"auto\">A customer asked:</p>\n<blockquote>\n<p dir=\"auto\">How do I update the version of Jenkins that is running in our Shared account and backing our CI/CD / GW pipelines solution?</p>\n</blockquote>\n<hr>\n<ins datetime=\"2022-07-07T20:03:35Z\">\n  <p dir=\"auto\"><a href=\"https://support.gruntwork.io/hc/requests/108940\" rel=\"nofollow\">Tracked in ticket #108940</a></p>\n</ins>","answer":{"body":"Clone your infrastructure-live repository to your machine.\r\n\r\nFind your `build_jenkins_server.sh` script: \r\n\r\n`find . -iname \"*jenkins*\" -not -path '*/.*'`\r\n\r\nFor example, if your PrimaryRegion (as defined in your reference-architecture-form.yml file) were `us-east-1` then your path would be `shared/us-east-1/_regional/amis/build_jenkins_server.sh`\r\n\r\nOpen the `build_jekins_server.sh` and search for `args` which will look something like the following: \r\n\r\n```bash\r\n  args=( \\\r\n    --packer-template-path \"git::$PACKER_TEMPLATE_REPO?ref=$PACKER_TEMPLATE_REPO_REF\" \\\r\n    --var service_catalog_ref=\"$SERVICE_CATALOG_REF\" \\\r\n    --var version_tag=\"$PACKER_TEMPLATE_REPO_REF\" \\\r\n    --var aws_region=\"$REGION\" \\\r\n    --var ami_users=\"$ami_account_ids\" \\\r\n    --var vpc_filter_key=\"tag:Name\" \\\r\n    --var vpc_filter_value=\"mgmt\" \\\r\n    --var vpc_subnet_filter_key=\"tag:Name\"\r\n    --var copy_to_regions=\"$pkr_copy_regions\" \\\r\n    --var encrypt_boot=true \\\r\n    --var encrypt_kms_key_id=\"arn:aws:kms:us-east-1:$shared_account_id:alias/ami-encryption\" \\\r\n    --var region_kms_key_ids=\"$pkr_kms_key_ids\" \\\r\n    --var instance_type=\"t2.medium\" # This is the instance type used to build the packer image, so you want it on the larger side for sufficient memory / vCPU. Consider bumping this to a larger instance.\r\n  )\r\n```\r\n\r\nNotice that within [[the Jenkins packer build file that we package into the service-catalog](https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/modules/mgmt/jenkins/jenkins-ubuntu.pkr.hcl)](https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/modules/mgmt/jenkins/jenkins-ubuntu.pkr.hcl), we expose a variable named `jenkins_version`: \r\n\r\n```bash\r\nvariable \"jenkins_version\" {\r\n  description = \"The version of jenkins to install.\"\r\n  type        = string\r\n  default     = \"\"\r\n}\r\n```\r\n\r\nNow, extend the args you’re passing in the `build_jenkins_server.sh` script to include `jenkins_version` set to your desired Jenkins version: \r\n\r\n```bash\r\n  args=( \\\r\n    --packer-template-path \"git::$PACKER_TEMPLATE_REPO?ref=$PACKER_TEMPLATE_REPO_REF\" \\\r\n    --var service_catalog_ref=\"$SERVICE_CATALOG_REF\" \\\r\n    --var version_tag=\"$PACKER_TEMPLATE_REPO_REF\" \\\r\n    --var jenkins_version=\"2.346.1\" \\\r\n    --var aws_region=\"$REGION\" \\\r\n    --var ami_users=\"$ami_account_ids\" \\\r\n    --var vpc_filter_key=\"tag:Name\" \\\r\n    --var vpc_filter_value=\"mgmt\" \\\r\n    --var vpc_subnet_filter_key=\"tag:Name\"\r\n    --var copy_to_regions=\"$pkr_copy_regions\" \\\r\n    --var encrypt_boot=true \\\r\n    --var encrypt_kms_key_id=\"arn:aws:kms:us-east-1:$shared_account_id:alias/ami-encryption\" \\\r\n    --var region_kms_key_ids=\"$pkr_kms_key_ids\" \\\r\n    --var instance_type=\"t2.medium\" # This is the instance type used to build the packer image, so you want it on the larger side for sufficient memory / vCPU. Consider bumping this to a larger instance.\r\n  )\r\n```\r\n\r\nNote that, if a Jenkins AMI was already built and is available in the shared account, you will either need to de-register that older AMI and recreate a new one with the same tags - or update your `version_tag` and or `service_catalog_ref` variables. Otherwise, the `build_jenkins_server.sh` script will see the target AMI as already existing, so it will abort early without building anything.\r\n\r\nAuthenticate to the shared account and build the new Jenkins AMI: \r\n\r\n`aws-vault exec <your-org>-shared -- bash ./build_jenkins_server.sh`\r\n\r\nWait until the new AMI’s status has changed from Pending to Available. At this point, you can now attempt to re-deploy the Jenkins AutoScaling group with the updated AMI. \r\n\r\nTo do so, cd into the `infrastructure-live-<your-org>shared/<primary-region>/mgmt/jenkins` . \r\n\r\nAuthenticate to the shared account and run terragrunt plan: \r\n\r\n`aws-vault exec <your-org>-shared -- terragrunt plan` \r\n\r\nYou should see the AMI being updated. Ensure that the target AMI for the replacement is identical to the AMI you just built. This should force replacement of the Jenkins instance’s launch configuration, as Jenkins is deployed within an Auto Scaling Group. \r\n\r\nIf the plan looks good, run apply: \r\n\r\n`aws-vault exec <your-org>-shared -- terragrunt apply --auto-approve`\r\n\r\nOnce the new Jenkins host comes up cleanly, you should be able to log back into it with an existing login. \r\n\r\nRolling the Jenkins version forward should not result in database changes that touch any existing accounts, so any admin accounts that were already defined should still work fine in the updated Jenkins instance.","bodyHTML":"<p dir=\"auto\">Clone your infrastructure-live repository to your machine.</p>\n<p dir=\"auto\">Find your <code class=\"notranslate\">build_jenkins_server.sh</code> script:</p>\n<p dir=\"auto\"><code class=\"notranslate\">find . -iname \"*jenkins*\" -not -path '*/.*'</code></p>\n<p dir=\"auto\">For example, if your PrimaryRegion (as defined in your reference-architecture-form.yml file) were <code class=\"notranslate\">us-east-1</code> then your path would be <code class=\"notranslate\">shared/us-east-1/_regional/amis/build_jenkins_server.sh</code></p>\n<p dir=\"auto\">Open the <code class=\"notranslate\">build_jekins_server.sh</code> and search for <code class=\"notranslate\">args</code> which will look something like the following:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"  args=( \\\n    --packer-template-path &quot;git::$PACKER_TEMPLATE_REPO?ref=$PACKER_TEMPLATE_REPO_REF&quot; \\\n    --var service_catalog_ref=&quot;$SERVICE_CATALOG_REF&quot; \\\n    --var version_tag=&quot;$PACKER_TEMPLATE_REPO_REF&quot; \\\n    --var aws_region=&quot;$REGION&quot; \\\n    --var ami_users=&quot;$ami_account_ids&quot; \\\n    --var vpc_filter_key=&quot;tag:Name&quot; \\\n    --var vpc_filter_value=&quot;mgmt&quot; \\\n    --var vpc_subnet_filter_key=&quot;tag:Name&quot;\n    --var copy_to_regions=&quot;$pkr_copy_regions&quot; \\\n    --var encrypt_boot=true \\\n    --var encrypt_kms_key_id=&quot;arn:aws:kms:us-east-1:$shared_account_id:alias/ami-encryption&quot; \\\n    --var region_kms_key_ids=&quot;$pkr_kms_key_ids&quot; \\\n    --var instance_type=&quot;t2.medium&quot; # This is the instance type used to build the packer image, so you want it on the larger side for sufficient memory / vCPU. Consider bumping this to a larger instance.\n  )\"><pre class=\"notranslate\">  args=( \\\n    --packer-template-path <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git::<span class=\"pl-smi\">$PACKER_TEMPLATE_REPO</span>?ref=<span class=\"pl-smi\">$PACKER_TEMPLATE_REPO_REF</span><span class=\"pl-pds\">\"</span></span> \\\n    --var service_catalog_ref=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$SERVICE_CATALOG_REF</span><span class=\"pl-pds\">\"</span></span> \\\n    --var version_tag=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$PACKER_TEMPLATE_REPO_REF</span><span class=\"pl-pds\">\"</span></span> \\\n    --var aws_region=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$REGION</span><span class=\"pl-pds\">\"</span></span> \\\n    --var ami_users=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$ami_account_ids</span><span class=\"pl-pds\">\"</span></span> \\\n    --var vpc_filter_key=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tag:Name<span class=\"pl-pds\">\"</span></span> \\\n    --var vpc_filter_value=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>mgmt<span class=\"pl-pds\">\"</span></span> \\\n    --var vpc_subnet_filter_key=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tag:Name<span class=\"pl-pds\">\"</span></span>\n    --var copy_to_regions=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$pkr_copy_regions</span><span class=\"pl-pds\">\"</span></span> \\\n    --var encrypt_boot=true \\\n    --var encrypt_kms_key_id=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>arn:aws:kms:us-east-1:<span class=\"pl-smi\">$shared_account_id</span>:alias/ami-encryption<span class=\"pl-pds\">\"</span></span> \\\n    --var region_kms_key_ids=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$pkr_kms_key_ids</span><span class=\"pl-pds\">\"</span></span> \\\n    --var instance_type=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t2.medium<span class=\"pl-pds\">\"</span></span> <span class=\"pl-c\"><span class=\"pl-c\">#</span> This is the instance type used to build the packer image, so you want it on the larger side for sufficient memory / vCPU. Consider bumping this to a larger instance.</span>\n  )</pre></div>\n<p dir=\"auto\">Notice that within [<a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/modules/mgmt/jenkins/jenkins-ubuntu.pkr.hcl\">the Jenkins packer build file that we package into the service-catalog</a>](<a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/modules/mgmt/jenkins/jenkins-ubuntu.pkr.hcl\">https://github.com/gruntwork-io/terraform-aws-service-catalog/blob/master/modules/mgmt/jenkins/jenkins-ubuntu.pkr.hcl</a>), we expose a variable named <code class=\"notranslate\">jenkins_version</code>:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"variable &quot;jenkins_version&quot; {\n  description = &quot;The version of jenkins to install.&quot;\n  type        = string\n  default     = &quot;&quot;\n}\"><pre class=\"notranslate\">variable <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>jenkins_version<span class=\"pl-pds\">\"</span></span> {\n  description = <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>The version of jenkins to install.<span class=\"pl-pds\">\"</span></span>\n  <span class=\"pl-c1\">type</span>        = string\n  default     = <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-pds\">\"</span></span>\n}</pre></div>\n<p dir=\"auto\">Now, extend the args you’re passing in the <code class=\"notranslate\">build_jenkins_server.sh</code> script to include <code class=\"notranslate\">jenkins_version</code> set to your desired Jenkins version:</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"  args=( \\\n    --packer-template-path &quot;git::$PACKER_TEMPLATE_REPO?ref=$PACKER_TEMPLATE_REPO_REF&quot; \\\n    --var service_catalog_ref=&quot;$SERVICE_CATALOG_REF&quot; \\\n    --var version_tag=&quot;$PACKER_TEMPLATE_REPO_REF&quot; \\\n    --var jenkins_version=&quot;2.346.1&quot; \\\n    --var aws_region=&quot;$REGION&quot; \\\n    --var ami_users=&quot;$ami_account_ids&quot; \\\n    --var vpc_filter_key=&quot;tag:Name&quot; \\\n    --var vpc_filter_value=&quot;mgmt&quot; \\\n    --var vpc_subnet_filter_key=&quot;tag:Name&quot;\n    --var copy_to_regions=&quot;$pkr_copy_regions&quot; \\\n    --var encrypt_boot=true \\\n    --var encrypt_kms_key_id=&quot;arn:aws:kms:us-east-1:$shared_account_id:alias/ami-encryption&quot; \\\n    --var region_kms_key_ids=&quot;$pkr_kms_key_ids&quot; \\\n    --var instance_type=&quot;t2.medium&quot; # This is the instance type used to build the packer image, so you want it on the larger side for sufficient memory / vCPU. Consider bumping this to a larger instance.\n  )\"><pre class=\"notranslate\">  args=( \\\n    --packer-template-path <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git::<span class=\"pl-smi\">$PACKER_TEMPLATE_REPO</span>?ref=<span class=\"pl-smi\">$PACKER_TEMPLATE_REPO_REF</span><span class=\"pl-pds\">\"</span></span> \\\n    --var service_catalog_ref=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$SERVICE_CATALOG_REF</span><span class=\"pl-pds\">\"</span></span> \\\n    --var version_tag=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$PACKER_TEMPLATE_REPO_REF</span><span class=\"pl-pds\">\"</span></span> \\\n    --var jenkins_version=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>2.346.1<span class=\"pl-pds\">\"</span></span> \\\n    --var aws_region=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$REGION</span><span class=\"pl-pds\">\"</span></span> \\\n    --var ami_users=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$ami_account_ids</span><span class=\"pl-pds\">\"</span></span> \\\n    --var vpc_filter_key=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tag:Name<span class=\"pl-pds\">\"</span></span> \\\n    --var vpc_filter_value=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>mgmt<span class=\"pl-pds\">\"</span></span> \\\n    --var vpc_subnet_filter_key=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tag:Name<span class=\"pl-pds\">\"</span></span>\n    --var copy_to_regions=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$pkr_copy_regions</span><span class=\"pl-pds\">\"</span></span> \\\n    --var encrypt_boot=true \\\n    --var encrypt_kms_key_id=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>arn:aws:kms:us-east-1:<span class=\"pl-smi\">$shared_account_id</span>:alias/ami-encryption<span class=\"pl-pds\">\"</span></span> \\\n    --var region_kms_key_ids=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-smi\">$pkr_kms_key_ids</span><span class=\"pl-pds\">\"</span></span> \\\n    --var instance_type=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t2.medium<span class=\"pl-pds\">\"</span></span> <span class=\"pl-c\"><span class=\"pl-c\">#</span> This is the instance type used to build the packer image, so you want it on the larger side for sufficient memory / vCPU. Consider bumping this to a larger instance.</span>\n  )</pre></div>\n<p dir=\"auto\">Note that, if a Jenkins AMI was already built and is available in the shared account, you will either need to de-register that older AMI and recreate a new one with the same tags - or update your <code class=\"notranslate\">version_tag</code> and or <code class=\"notranslate\">service_catalog_ref</code> variables. Otherwise, the <code class=\"notranslate\">build_jenkins_server.sh</code> script will see the target AMI as already existing, so it will abort early without building anything.</p>\n<p dir=\"auto\">Authenticate to the shared account and build the new Jenkins AMI:</p>\n<p dir=\"auto\"><code class=\"notranslate\">aws-vault exec &lt;your-org&gt;-shared -- bash ./build_jenkins_server.sh</code></p>\n<p dir=\"auto\">Wait until the new AMI’s status has changed from Pending to Available. At this point, you can now attempt to re-deploy the Jenkins AutoScaling group with the updated AMI.</p>\n<p dir=\"auto\">To do so, cd into the <code class=\"notranslate\">infrastructure-live-&lt;your-org&gt;shared/&lt;primary-region&gt;/mgmt/jenkins</code> .</p>\n<p dir=\"auto\">Authenticate to the shared account and run terragrunt plan:</p>\n<p dir=\"auto\"><code class=\"notranslate\">aws-vault exec &lt;your-org&gt;-shared -- terragrunt plan</code></p>\n<p dir=\"auto\">You should see the AMI being updated. Ensure that the target AMI for the replacement is identical to the AMI you just built. This should force replacement of the Jenkins instance’s launch configuration, as Jenkins is deployed within an Auto Scaling Group.</p>\n<p dir=\"auto\">If the plan looks good, run apply:</p>\n<p dir=\"auto\"><code class=\"notranslate\">aws-vault exec &lt;your-org&gt;-shared -- terragrunt apply --auto-approve</code></p>\n<p dir=\"auto\">Once the new Jenkins host comes up cleanly, you should be able to log back into it with an existing login.</p>\n<p dir=\"auto\">Rolling the Jenkins version forward should not result in database changes that touch any existing accounts, so any admin accounts that were already defined should still work fine in the updated Jenkins instance.</p>"}}} />

</CenterLayout>

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "296fbd1caec3845f0d61529fb20d4b42"
}
##DOCS-SOURCER-END -->
