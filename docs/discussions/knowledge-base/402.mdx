---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/402" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>Terragrunt architecture best practices?</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84APcua","number":402,"author":{"login":"yorinasub17"},"title":"Terragrunt architecture best practices?","body":"I’m getting started with Terragrunt and want to make sure I have this conceptually right. It looks like we can only source a single module from, e.g. `my-app/terragrunt.hcl`. So if my app needs, say, an ASG, a security group, and a load balancer, I might create `modules/my-app/` and source 3 modules from there. Is that right?\r\n\r\nHaving the `terragrunt.hcl` reference a fairly specific module that references 3 other re-usable modules seems a bit odd to me, so I’m not sure I’m thinking about this right. Especially since we’re using Gruntwork modules, so each of those three re-usable modules is really a wrapper for a Gruntwork module. The chain of nested modules seems to get long pretty quickly.","bodyHTML":"<p dir=\"auto\">I’m getting started with Terragrunt and want to make sure I have this conceptually right. It looks like we can only source a single module from, e.g. <code class=\"notranslate\">my-app/terragrunt.hcl</code>. So if my app needs, say, an ASG, a security group, and a load balancer, I might create <code class=\"notranslate\">modules/my-app/</code> and source 3 modules from there. Is that right?</p>\n<p dir=\"auto\">Having the <code class=\"notranslate\">terragrunt.hcl</code> reference a fairly specific module that references 3 other re-usable modules seems a bit odd to me, so I’m not sure I’m thinking about this right. Especially since we’re using Gruntwork modules, so each of those three re-usable modules is really a wrapper for a Gruntwork module. The chain of nested modules seems to get long pretty quickly.</p>","answer":{"body":"The core of Terragrunt architecture is considering how you want to break apart the Terraform state. While Terraform is optimized for working with a single state file, Terragrunt supports breaking apart your Terraform state into multiple component infrastructure through it's many features like `dependency`.\r\n\r\nHowever, since Terragrunt ultimately relies on Terraform under the hood, it is limited by Terraform's ability to have a single root module, and that's why you still need to define a single Terraform module to act as the root module for Terragrunt to invoke at the folder level.\r\n\r\nThe way we at Gruntwork think about this is to differentiate between Services and Modules (See our [blog post on Modules, Services, and Architectures](https://blog.gruntwork.io/introducing-the-gruntwork-module-service-and-architecture-catalogs-eb3a21b99f70) for more details). The Service module is an opinionated, specific way to deploy components that fit the needs of your organization, which is less reusable, but is designed to be directly deployed by Terragrunt. If you look at our Service module for the ASG ([asg-service](https://github.com/gruntwork-io/terraform-aws-service-catalog/tree/master/modules/services/asg-service)), you will see that it combines the Gruntwork modules to construct the deployable ASG unit.\r\n\r\nGiven that, you should be striving for 2 links in your chain: Services and Modules. That is, when extending Gruntwork modules, it is oftentimes much better organizationally to extend them in the Service layer by combining Gruntwork modules with resources and modules to create the deployable unit, rather than extending Gruntwork modules to create more Modules. This should significantly help with the dependency management.","bodyHTML":"<p dir=\"auto\">The core of Terragrunt architecture is considering how you want to break apart the Terraform state. While Terraform is optimized for working with a single state file, Terragrunt supports breaking apart your Terraform state into multiple component infrastructure through it's many features like <code class=\"notranslate\">dependency</code>.</p>\n<p dir=\"auto\">However, since Terragrunt ultimately relies on Terraform under the hood, it is limited by Terraform's ability to have a single root module, and that's why you still need to define a single Terraform module to act as the root module for Terragrunt to invoke at the folder level.</p>\n<p dir=\"auto\">The way we at Gruntwork think about this is to differentiate between Services and Modules (See our <a href=\"https://blog.gruntwork.io/introducing-the-gruntwork-module-service-and-architecture-catalogs-eb3a21b99f70\" rel=\"nofollow\">blog post on Modules, Services, and Architectures</a> for more details). The Service module is an opinionated, specific way to deploy components that fit the needs of your organization, which is less reusable, but is designed to be directly deployed by Terragrunt. If you look at our Service module for the ASG (<a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/tree/master/modules/services/asg-service\">asg-service</a>), you will see that it combines the Gruntwork modules to construct the deployable ASG unit.</p>\n<p dir=\"auto\">Given that, you should be striving for 2 links in your chain: Services and Modules. That is, when extending Gruntwork modules, it is oftentimes much better organizationally to extend them in the Service layer by combining Gruntwork modules with resources and modules to create the deployable unit, rather than extending Gruntwork modules to create more Modules. This should significantly help with the dependency management.</p>"}}} />

</CenterLayout>

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "5d5aa4b7b25fab3f41a2902f9256a408"
}
##DOCS-SOURCER-END -->
