---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/769" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>How should I create the backend (e.g., S3 bucket) for storing Terraform state?</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84AVetk","number":769,"author":{"login":"brikis98"},"title":"How should I create the backend (e.g., S3 bucket) for storing Terraform state?","body":"\n_We get the following question from customers fairly often, so I'll post the question here, and then add an answer below:_\r\n\r\nHow should I create the backend (e.g., S3 bucket) for storing Terraform state?\n\n---\n\n<ins datetime=\"2023-09-15T09:37:50Z\">\n  <p><a href=\"https://support.gruntwork.io/hc/requests/110450\">Tracked in ticket #110450</a></p>\n</ins>\n","bodyHTML":"<p dir=\"auto\"><em>We get the following question from customers fairly often, so I'll post the question here, and then add an answer below:</em></p>\n<p dir=\"auto\">How should I create the backend (e.g., S3 bucket) for storing Terraform state?</p>\n<hr>\n<ins datetime=\"2023-09-15T09:37:50Z\">\n  <p dir=\"auto\"><a href=\"https://support.gruntwork.io/hc/requests/110450\" rel=\"nofollow\">Tracked in ticket #110450</a></p>\n</ins>","answer":{"body":"There are several different ways to handle this, each with various pros and cons:\r\n\r\n# Option 1: create the backend manually (ClickOps)\r\n\r\n## Overview\r\n\r\nOne option is to create your backend manually. For example, if you're using S3 as a backend, you'd login to the AWS Console, and click around for a while to create an S3 bucket and DynamoDB table.\r\n\r\n## Pros\r\n\r\n- It's an easy way to get started. If you only have a small number of backends to manage (e.g., your whole company just needs 1-3 S3 buckets), this approach works just fine.\r\n- You avoid the \"chicken & egg\" problem described below.\r\n- You can configure your backend however you want.\r\n\r\n## Cons\r\n\r\n- It's a manual process, so if you need more backends in the future, and/or you have a lot of backends to manage (e.g., dozens or hundreds of S3 buckets), this approach does not scale well.\r\n- You're not managing all your infrastructure as code. \r\n- How you set up the backend is not documented, so if you need to do it again the future, it won't be obvious to your team members what to do.\r\n- It's easy to make mistakes while doing ClickOps: e.g., you might forget to turn on an important security setting for your S3 bucket.\r\n\r\n# Option 2: create the backend using Terraform\r\n\r\n## Overview\r\n\r\nAnother option is to write a Terraform module to set up your backend. For example, if you're a Gruntwork customer, you can use the [s3-bucket module](https://docs.gruntwork.io/reference/services/data-storage/s-3-bucket/) to create a secure, best-practices S3 bucket. As for the DynamoDB table, it's a single resource ([example](https://github.com/brikis98/terraform-up-and-running-code/blob/3rd-edition/code/terraform/03-terraform-state/file-layout-example/global/s3/main.tf#L55-L64)).\r\n\r\n## The chicken & egg problem\r\n\r\nOne catch here is that you have a bit of a **_chicken & egg_** problem: you want to store all your Terraform state in a backend, but here, the Terraform code you're deploying is what creates the backend, which doesn't exist initially, so you can't store state in it. Working around this is pretty simple, but does involve some manual steps:\r\n\r\n1. Run `init` and `apply` on your backend module _without_ configuring any sort of `backend` in your code. \r\n2. When `apply` completes, your backend will be set up (e.g., the S3 bucket and DynamoDB table will now exist), and the state file for your backend module will be sitting on your local disk drive (`terraform.tfstate`).\r\n3. At this point, configure a `backend` block for your backend module to store its state in the backend you just created.\r\n4. Run `init` again. Terraform will prompt you to migrate the local state file (`terraform.tfstate`) into your backend. Say, \"yes.\"\r\n\r\nNote that you have to do these steps _before_ you can run `apply` on any other modules in this environment, as those modules need this backend to be set up first. So this approach involves some ordering dependencies when setting up new environments.\r\n\r\n## Pros\r\n\r\n- If you can automate this process (see \"Cons\" below), the solution scales reasonably well.\r\n- Everything is managed as code.\r\n- The code acts as documentation for how the backend is configured, so future team members will be able to figure out how to set up backends for new environments.\r\n- You are using code to manage your backend configuration, so you avoid manual errors.\r\n- You can configure your backend however you want.\r\n\r\n## Cons\r\n\r\n- It's harder to get started, as you have to write code and set up processes.\r\n- You have the chicken and egg problem: a series of manual steps to create backend and then have the backend module use the backend it just created.\r\n- You have to enforce ordering, ensuring that the backend module is the first thing deployed in each new environment.\r\n\r\n# Option 3: let Terragrunt create your backend\r\n\r\n## Overview\r\n\r\nFor a few popular backend types (S3 and GCS), if you're using the [remote_state block](https://terragrunt.gruntwork.io/docs/reference/config-blocks-and-attributes/#remote_state), Terragrunt can automatically create the backend for you. That is, when you run `terragrunt init` or `terragrunt apply`, Terragrunt will check if the backend exists, and if it doesn't, it'll make API calls to set up the backend automatically / transparently, following best practices.\r\n\r\n## Pros\r\n\r\n- It's an easy way to get started, as Terragrunt handles the backend set up for you.\r\n- It's a fully automated process and it scales well. \r\n- Everything is managed as code (the `remote_state` block configures your backend).\r\n- The code acts as documentation for how the backend is configured (along with Terragrunt's docs), so future team members will be able to figure out how to set up backends for new environments.\r\n- You are using code to manage your backend configuration, so you avoid manual errors.\r\n- You avoid the chicken & egg problem described above. Even ordering isn't a problem, as Terragrunt handles locking to deal with concurrency (e.g., if two modules try to use the same backend that doesn't exist at the same time, one will create it, and the other will wait).\r\n\r\n## Cons\r\n\r\n- Not all backend types are supported.\r\n- You have some ability to customize the backend configuration, and Terragrunt does try to follow best practices by default, but you don't have as much control as when you set up the backend yourself using ClickOps or a Terraform module.\r\n- Terragrunt currently doesn't have a built in way to _update_ existing backends. So creation is handled automatically, but if later on, you need to evolve your backend approach, that's more of a manual process.\r\n\r\n# Option 4: use a SaaS managed backend\r\n\r\n## Overview\r\n\r\nSome SaaS tools for Terraform, such as Terraform Cloud and Terraform Enterprise, manage backend for you \"magically.\" That is, you don't have to think about the backend at all: the SaaS tool just does it automatically, transparently, behind the scenes.\r\n\r\n## Pros\r\n\r\n- It's an easy way to get started, as the SaaS tool handles the backend set up for you.\r\n- It's a fully automated process and it scales well.\r\n- You don't really have documentation for how to set up new backends, but you don't entirely need it, as the SaaS does it magically.\r\n- The SaaS tool does all the work for you automatically, so you avoid manual errors.\r\n- You avoid the chicken & egg problem described above. \r\n\r\n## Cons\r\n\r\n- You aren't really managing things as code. They are just managed magically by the SaaS.\r\n- For the most part, you can't customize how your state is stored. You just have to trust the SaaS tool is doing the right thing. Note that state files contain secrets, so you are putting a lot of trust in this SaaS tool.\r\n- Lock in. Migrating away from the SaaS can be tricky.\r\n- Migrating state is a bit tricky.","bodyHTML":"<p dir=\"auto\">There are several different ways to handle this, each with various pros and cons:</p>\n<h1 dir=\"auto\">Option 1: create the backend manually (ClickOps)</h1>\n<h2 dir=\"auto\">Overview</h2>\n<p dir=\"auto\">One option is to create your backend manually. For example, if you're using S3 as a backend, you'd login to the AWS Console, and click around for a while to create an S3 bucket and DynamoDB table.</p>\n<h2 dir=\"auto\">Pros</h2>\n<ul dir=\"auto\">\n<li>It's an easy way to get started. If you only have a small number of backends to manage (e.g., your whole company just needs 1-3 S3 buckets), this approach works just fine.</li>\n<li>You avoid the \"chicken &amp; egg\" problem described below.</li>\n<li>You can configure your backend however you want.</li>\n</ul>\n<h2 dir=\"auto\">Cons</h2>\n<ul dir=\"auto\">\n<li>It's a manual process, so if you need more backends in the future, and/or you have a lot of backends to manage (e.g., dozens or hundreds of S3 buckets), this approach does not scale well.</li>\n<li>You're not managing all your infrastructure as code.</li>\n<li>How you set up the backend is not documented, so if you need to do it again the future, it won't be obvious to your team members what to do.</li>\n<li>It's easy to make mistakes while doing ClickOps: e.g., you might forget to turn on an important security setting for your S3 bucket.</li>\n</ul>\n<h1 dir=\"auto\">Option 2: create the backend using Terraform</h1>\n<h2 dir=\"auto\">Overview</h2>\n<p dir=\"auto\">Another option is to write a Terraform module to set up your backend. For example, if you're a Gruntwork customer, you can use the <a href=\"https://docs.gruntwork.io/reference/services/data-storage/s-3-bucket/\" rel=\"nofollow\">s3-bucket module</a> to create a secure, best-practices S3 bucket. As for the DynamoDB table, it's a single resource (<a href=\"https://github.com/brikis98/terraform-up-and-running-code/blob/3rd-edition/code/terraform/03-terraform-state/file-layout-example/global/s3/main.tf#L55-L64\">example</a>).</p>\n<h2 dir=\"auto\">The chicken &amp; egg problem</h2>\n<p dir=\"auto\">One catch here is that you have a bit of a <strong><em>chicken &amp; egg</em></strong> problem: you want to store all your Terraform state in a backend, but here, the Terraform code you're deploying is what creates the backend, which doesn't exist initially, so you can't store state in it. Working around this is pretty simple, but does involve some manual steps:</p>\n<ol dir=\"auto\">\n<li>Run <code class=\"notranslate\">init</code> and <code class=\"notranslate\">apply</code> on your backend module <em>without</em> configuring any sort of <code class=\"notranslate\">backend</code> in your code.</li>\n<li>When <code class=\"notranslate\">apply</code> completes, your backend will be set up (e.g., the S3 bucket and DynamoDB table will now exist), and the state file for your backend module will be sitting on your local disk drive (<code class=\"notranslate\">terraform.tfstate</code>).</li>\n<li>At this point, configure a <code class=\"notranslate\">backend</code> block for your backend module to store its state in the backend you just created.</li>\n<li>Run <code class=\"notranslate\">init</code> again. Terraform will prompt you to migrate the local state file (<code class=\"notranslate\">terraform.tfstate</code>) into your backend. Say, \"yes.\"</li>\n</ol>\n<p dir=\"auto\">Note that you have to do these steps <em>before</em> you can run <code class=\"notranslate\">apply</code> on any other modules in this environment, as those modules need this backend to be set up first. So this approach involves some ordering dependencies when setting up new environments.</p>\n<h2 dir=\"auto\">Pros</h2>\n<ul dir=\"auto\">\n<li>If you can automate this process (see \"Cons\" below), the solution scales reasonably well.</li>\n<li>Everything is managed as code.</li>\n<li>The code acts as documentation for how the backend is configured, so future team members will be able to figure out how to set up backends for new environments.</li>\n<li>You are using code to manage your backend configuration, so you avoid manual errors.</li>\n<li>You can configure your backend however you want.</li>\n</ul>\n<h2 dir=\"auto\">Cons</h2>\n<ul dir=\"auto\">\n<li>It's harder to get started, as you have to write code and set up processes.</li>\n<li>You have the chicken and egg problem: a series of manual steps to create backend and then have the backend module use the backend it just created.</li>\n<li>You have to enforce ordering, ensuring that the backend module is the first thing deployed in each new environment.</li>\n</ul>\n<h1 dir=\"auto\">Option 3: let Terragrunt create your backend</h1>\n<h2 dir=\"auto\">Overview</h2>\n<p dir=\"auto\">For a few popular backend types (S3 and GCS), if you're using the <a href=\"https://terragrunt.gruntwork.io/docs/reference/config-blocks-and-attributes/#remote_state\" rel=\"nofollow\">remote_state block</a>, Terragrunt can automatically create the backend for you. That is, when you run <code class=\"notranslate\">terragrunt init</code> or <code class=\"notranslate\">terragrunt apply</code>, Terragrunt will check if the backend exists, and if it doesn't, it'll make API calls to set up the backend automatically / transparently, following best practices.</p>\n<h2 dir=\"auto\">Pros</h2>\n<ul dir=\"auto\">\n<li>It's an easy way to get started, as Terragrunt handles the backend set up for you.</li>\n<li>It's a fully automated process and it scales well.</li>\n<li>Everything is managed as code (the <code class=\"notranslate\">remote_state</code> block configures your backend).</li>\n<li>The code acts as documentation for how the backend is configured (along with Terragrunt's docs), so future team members will be able to figure out how to set up backends for new environments.</li>\n<li>You are using code to manage your backend configuration, so you avoid manual errors.</li>\n<li>You avoid the chicken &amp; egg problem described above. Even ordering isn't a problem, as Terragrunt handles locking to deal with concurrency (e.g., if two modules try to use the same backend that doesn't exist at the same time, one will create it, and the other will wait).</li>\n</ul>\n<h2 dir=\"auto\">Cons</h2>\n<ul dir=\"auto\">\n<li>Not all backend types are supported.</li>\n<li>You have some ability to customize the backend configuration, and Terragrunt does try to follow best practices by default, but you don't have as much control as when you set up the backend yourself using ClickOps or a Terraform module.</li>\n<li>Terragrunt currently doesn't have a built in way to <em>update</em> existing backends. So creation is handled automatically, but if later on, you need to evolve your backend approach, that's more of a manual process.</li>\n</ul>\n<h1 dir=\"auto\">Option 4: use a SaaS managed backend</h1>\n<h2 dir=\"auto\">Overview</h2>\n<p dir=\"auto\">Some SaaS tools for Terraform, such as Terraform Cloud and Terraform Enterprise, manage backend for you \"magically.\" That is, you don't have to think about the backend at all: the SaaS tool just does it automatically, transparently, behind the scenes.</p>\n<h2 dir=\"auto\">Pros</h2>\n<ul dir=\"auto\">\n<li>It's an easy way to get started, as the SaaS tool handles the backend set up for you.</li>\n<li>It's a fully automated process and it scales well.</li>\n<li>You don't really have documentation for how to set up new backends, but you don't entirely need it, as the SaaS does it magically.</li>\n<li>The SaaS tool does all the work for you automatically, so you avoid manual errors.</li>\n<li>You avoid the chicken &amp; egg problem described above.</li>\n</ul>\n<h2 dir=\"auto\">Cons</h2>\n<ul dir=\"auto\">\n<li>You aren't really managing things as code. They are just managed magically by the SaaS.</li>\n<li>For the most part, you can't customize how your state is stored. You just have to trust the SaaS tool is doing the right thing. Note that state files contain secrets, so you are putting a lot of trust in this SaaS tool.</li>\n<li>Lock in. Migrating away from the SaaS can be tricky.</li>\n<li>Migrating state is a bit tricky.</li>\n</ul>"}}} />

</CenterLayout>

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "b0f3648d240c1b7af41a012db69fd796"
}
##DOCS-SOURCER-END -->
