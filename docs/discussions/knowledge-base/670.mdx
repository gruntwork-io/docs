---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<head>
  <link rel="canonical" href="https://github.com/gruntwork-io/knowledge-base/discussions/670" />
</head>

<CenterLayout>
<span className="searchCategory">Knowledge Base</span>
<h1>How do I add a module to my Reference Architecture?</h1>
<GitHub discussion={{"id":"D_kwDOF8slf84ASrC6","number":670,"author":{"login":"iangrunt"},"title":"How do I add a module to my Reference Architecture?","body":"\nI have a Reference Architecture that only uses the modules it was deployed with. However, there are many other Gruntwork, open-source, and custom modules I also need to deploy. Do you know how I can do that? \n\n---\n\n<ins datetime=\"2023-02-24T18:00:14Z\">\n  <p><a href=\"https://support.gruntwork.io/hc/requests/109931\">Tracked in ticket #109931</a></p>\n</ins>\n","bodyHTML":"<p dir=\"auto\">I have a Reference Architecture that only uses the modules it was deployed with. However, there are many other Gruntwork, open-source, and custom modules I also need to deploy. Do you know how I can do that?</p>\n<hr>\n<ins datetime=\"2023-02-24T18:00:14Z\">\n  <p dir=\"auto\"><a href=\"https://support.gruntwork.io/hc/requests/109931\" rel=\"nofollow\">Tracked in ticket #109931</a></p>\n</ins>","answer":{"body":"## Deploy a new module in the Reference Architecture\r\nThere are several ways you can accomplish this. I'll start from the most basic form, then extend that basic structure to be fully [\"DRY\"](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) by following the `_envcommon` pattern used here at Gruntwork.\r\n\r\n### TL;DR\r\nWe must create a new `terragrunt.hcl` file that points to the location of the Terraform module we want to deploy. This new Terragrunt file will live in its own directory, separate from the other modules inside your Reference Architecture's repository. \r\n\r\n> üìç Writing and updating the `infrastructure-live` codebase is the only work that should be done on your local machine; the deployment happens through GitOps and a serverless CI/CD architecture called **Gruntwork Pipelines** that was built for you as part of the Reference Architecture deployment. \r\n\r\n**_Where_** we create this new directory matters. The filesystem path dictates where in AWS the infrastructure will be deployed, e.g., `development/us-east-2/development/services/eks-cluster/terragrunt.hcl` will look up the EKS Terraform module and then deploy it in:\r\n- The `development` AWS account\r\n  - In the `us-east-2` AWS region\r\n    - Into the `app` VPC created during the initial Reference Architecture deployment, which is represented by the second `development` directory in the full module path. \r\n> üåü There are actually two VPCs in each AWS account when the Reference Architecture is initially deployed; `app`, where the sample app runs, and `mgmt`, which runs Gruntwork Pipelines. The code for both lives inside your `infrastructure-live` repository, and the latter is represented by something like `development/us-east-2/mgmt/networking/vpc`. \r\n\r\nSince each deployed _instance_ of Terraform module will have its own directory, you should give meaningful names to them like `payments-eks-cluster` or `risk-mgmt-aurora-database` that will be used across all environments, e.g., the `data-team-ecs` module be called three times, once for each environment, so it will exist in:\r\n- `prod/us-west-2/data-team-ecs`\r\n- `stage/us-west-2/data-team-ecs`\r\n- `dev/us-east-2/data-team-ecs`\r\n\r\nOnce you've created your module directory and `terragrunt.hcl`, you can open up a pull request with your changes, merge it, and Gruntwork Pipelines will **_automatically deploy_** your Terraform module into the correct account and region.\r\n\r\n```hcl\r\n# Create a directory and file in your Reference Architecture, something like:\r\n# development/us-east-2/development/services/demo-eks-cluster/terragrunt.hcl\r\n\r\n# Define the Terraform module you want to deploy\r\nterraform {\r\n  source = \"git@example.com:example-org/your-modules-here.git//modules/eks-cluster?ref=v0.0.1\"\r\n}\r\n\r\n# Include the `terragrunt.hcl` located in the root of our Reference Architecture's\r\n# repository because this file contains all the templating required to make our\r\n# Terraform state and AWS provider DRY.\r\ninclude \"root\" {\r\n  path = find_in_parent_folders()\r\n}\r\n\r\n# Your module will expect some inputs. This is how to pass in values for those inputs:\r\ninputs = {\r\n  name   = \"development-eks-cluster\"\r\n  vpc_id = \"vpc-85556dc\"\r\n}\r\n```\r\n\r\n> ‚ö†Ô∏è This is **not DRY**, as we'd end up with duplicate code across environments. How to DRY up this code using Terragrunt and the `_envcommon` pattern is explained in the following guide.\r\n\r\n\r\n### Background\r\nIf we want to follow the already deployed modules' pattern, we'll first need a new directory and a `terragrunt.hcl` file. The directory name should be meaningful. For example, suppose we had a `development` environment with five different ECS clusters. In that case, we'd need a directory for each ECS cluster, as those folders contain the `terragrunt.hcl` file that calls the Terraform module to create them. So it would look something like this:\r\n```\r\ndevelopment/us-east-2/development/services 0 $ tree\r\n.\r\n‚îú‚îÄ‚îÄ team-a-ecs\r\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\r\n‚îú‚îÄ‚îÄ team-b-ecs\r\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\r\n‚îú‚îÄ‚îÄ team-c-ecs\r\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\r\n‚îú‚îÄ‚îÄ team-d-ecs\r\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\r\n‚îî‚îÄ‚îÄ team-e-ecs\r\n    ‚îî‚îÄ‚îÄ terragrunt.hcl\r\n```\r\n\r\nEach of those `terragrunt.hcl` files would look something like this:\r\n```hcl\r\n# development/us-east-2/development/services/team-e-ecs/terragrunt.hcl\r\n\r\n# This is where we tell Terragrunt what Terraform module we want to deploy.\r\nterraform {\r\n  source = \"git@example.com:gruntwork-io/terraform-aws-service-catalog.git//modules/services/ecs-cluster?ref=v0.0.1\"\r\n}\r\n\r\n# This is where we provide the input values to the Terraform module we want to deploy.\r\ninputs = {\r\n  cluster_name          = \"Team E\"\r\n  cluster_instance_type = \"t2.micro\"\r\n}\r\n\r\n```\r\n\r\n### How to add a module using a new `terragrunt.hcl` file\r\nIn my case, I will add a `demo-vpc` directory with a `terragrunt.hcl` file that deploys an elementary module to my existing Reference Architecture. The first step would be creating my directory and Terragrunt file:\r\n\r\n```\r\nmkdir development/us-east-2/development/services/demo-vpc\r\n```\r\n\r\n```\r\ncd development/us-east-2/development/services/demo-vpc && touch terragrunt.hcl\r\n```\r\n\r\nSince my [demo module](https://github.com/gruntwork-io/terraform-fake-modules/tree/main/modules/aws/vpc) doesn't expect any inputs, I _could_ quickly (**but don't)** get started by only having this one block in my `terragrunt.hcl` file:\r\n```hcl\r\n# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\r\n\r\nterraform {\r\n  source = \"git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main\"\r\n}\r\n```\r\n\r\nAnd it _will_ run just fine, but can you **spot the bug** üêû in our thinking?\r\n\r\n> ‚è∞ **Hint:** Consider the lack of Terraform configuration in our `terragrunt.hcl` file and remember Terragrunt is a _thin_ wrapper for Terraform, not a replacement, and does not remove the need for fundamental concepts like providers and state.\r\n\r\n![Screen Shot 2023-02-24 at 1 44 35 PM](https://user-images.githubusercontent.com/101607944/221265019-a2608768-6ed4-4e17-9aca-a0081ef3c315.png)\r\n\r\n###  ‚ö†Ô∏è The issue with the above Terragrunt configuration (and not being _DRY_ enough) \r\nIf we run this job, everything will be created as expected, but if we re-run this job, it will create **duplicate resources**. This is bad for a number of reasons; not only will we have duplicate infrastructure that could potentially spin up and overload other services, but we also cannot quickly and cleanly destroy the duplicate infrastructure that's been created. What we need to do is define a **[Terraform state](https://developer.hashicorp.com/terraform/language/state)** to keep track of all the infrastructure that has come in and out of service. If our Terraform configuration was set up correctly, instead of recreating these resources, it would detect they already exist and that there are no configuration changes, so the deployment will do [nothing](https://en.wikipedia.org/wiki/NOP_(code)). Let's understand what happened with this example and then remediate it in the following sections. \r\n\r\n![Screen Shot 2023-02-24 at 1 51 16 PM](https://user-images.githubusercontent.com/101607944/221267080-620fc27c-4cc2-45d3-bff4-4c68d9a8429f.png)\r\n\r\n### So what happened when we re-ran our deployment, and how do we fix it?\r\nWe didn't define an S3 backend to store our Terraform state in. This behavior occurs because Gruntwork Pipelines uses serverless runners on ECS for the actual deployment. When we did the first `apply`, the state was stored locally. However, that runner was spun down, and that local state was lost. The second `apply` recreated those resources, unaware of previous CI/CD jobs. The Gruntwork Pipelines [architecture](https://docs.gruntwork.io/guides/build-it-yourself/pipelines/core-concepts/threat-model-of-ci-cd/) has many benefits but requires following best practices. Using a remote Terraform state is a major one of those best practices we enforce, but we also follow a pattern (described below) to make it painless to manage at scale. \r\n\r\n> üìç No matter what you use for CI/CD, always use a remote backend for your Terraform state! \r\n\r\nIn our `demo-vpc/terragrunt.hcl` file above, we got away with a lot, like Gruntwork Pipelines finding a default AWS provider automatically, but we can do better than that.\r\n\r\nTo solve this, we _could_ **(but don't)** modify our `demo-vpc/terragrunt.hcl` to look something like this:\r\n```hcl\r\n# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\r\n\r\nterraform {\r\n  source = \"git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main\"\r\n}\r\n\r\n# Non-DRY example, do not use!\r\n remote_state {\r\n    backend = \"s3\"\r\n    config = {\r\n      bucket = \"mybucket\"\r\n      key    = \"path/to/my/key\"\r\n      region = \"us-east-1\"\r\n    }\r\n  }\r\n```\r\nBut if we had thousands of resources to manage, defining that `remote_state` block for every Terraform module we use would become burdensome and dangerous.\r\n\r\n### üçè Managing our Terraform state using DRY principals \r\nIn the **root** of our `infrastructure-live` repository that contains our Reference Architecture, there is a `terragrunt.hcl` file.\r\n\r\n![Screen Shot 2023-02-24 at 2 08 26 PM](https://user-images.githubusercontent.com/101607944/221269844-bec58a96-c5b0-4629-bb16-4d635745e054.png)\r\n\r\nInside this file, you'll see a block of HCL that looks like this:\r\n```hcl\r\n# ----------------------------------------------------------------------------------------------------------------\r\n# GENERATED REMOTE STATE BLOCK\r\n# ----------------------------------------------------------------------------------------------------------------\r\n# Generate the Terraform remote state block for storing state in S3\r\nremote_state {\r\n  backend = \"s3\"\r\n  config = {\r\n    encrypt                   = true\r\n    bucket                    = lower(\"${local.name_prefix}-${local.account_name}-${local.aws_region}-tf-state\")\r\n    key                       = \"${path_relative_to_include()}/terraform.tfstate\"\r\n    // ...\r\n```\r\n\r\n> üÜí Note that the only **hardcoded value** is `encrypt = true`, which is desirable for this use case, but the rest are parameterized strings used to automatically gather environment context and use that to define values for things like the `bucket` name and `terraform.tfstate` location inside S3. Pretty cool, but how do we use it?\r\n\r\n### Not repeating ourselves\r\nTo access this generated remote state block that will automatically take care of everything for us, we need to _include_ the **root `terragrunt.hcl`** into our `demo-vpc/terragrunt.hcl` by doing the following:\r\n\r\n```hcl\r\n# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\r\n\r\n# Create our \"VPC.\" In reality, this module outputs data that looks like a VPC was created).\r\nterraform {\r\n  source = \"git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main\"\r\n}\r\n\r\n# Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.\r\ninclude \"root\" {\r\n  path = find_in_parent_folders()\r\n}\r\n```\r\n\r\n### Adding inputs before deploying our module\r\nThis part is straightforward. Even though my module doesn't expect any inputs, I will add some since 99% of modules out there expect some value.\r\n```hcl\r\n# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\r\n\r\n# Create our \"VPC.\" In reality, this module outputs data that looks like a VPC was created).\r\nterraform {\r\n  source = \"git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main\"\r\n}\r\n\r\n# Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.\r\ninclude \"root\" {\r\n  path = find_in_parent_folders()\r\n}\r\n\r\n# This module expects no inputs, but most will expect at least a few. This is how I input those values.\r\ninputs = {\r\n  cidr_block = \"10.222.0.0/18\"\r\n  nat_gw_count = 1\r\n}\r\n```\r\n\r\n### Merging and what to expect\r\nOpen up a pull request with your new `terragrunt.hcl` file and module directory, review the `terragrunt plan` output, approve it, and hit merge. Gruntwork Pipelines will **deploy it in the correct environment automatically** üü¢ . Nothing should be run from a local workstation. \r\n\r\nSuppose this is the first time you're deploying your specific Terraform module. In that case, Terragrunt will automatically create the remote state for you based on the above changes we made to `demo-vpc/terragrunt.hcl` by including the root `terragrunt.hcl` that contains all of the generated remote state information. The scripts that initialize Gruntwork Pipelines and use `git-updated-folders` to understand what environments have changed are in the `_ci` directory.\r\n\r\nIf we look in S3, we'll see that a brand new `terraform.tfstate` file in a brand new location that matches our location in the repository, `development/us-east-2/development/services/demo-vpc/terragrunt.hcl`, in a bucket that matches `lower(\"${local.name_prefix}-${local.account_name}-${local.aws_region}-tf-state\")`.\r\n![Screen Shot 2023-02-24 at 2 30 28 PM](https://user-images.githubusercontent.com/101607944/221279954-367508c6-8d6f-4564-bc86-481dc9e8d48c.png)\r\n\r\n## Create global configurations in `_envcommon` to be DRY\r\nWe have now made the Terraform state and AWS provider information DRY, but If we wanted to launch our `demo-vpc` in the `staging` environment? The most obvious answer is to do something like this:\r\n\r\n```hcl\r\n# staging/us-east-2/staging/services/demo-vpc/terragrunt.hcl\r\n\r\n# Create our \"VPC.\" In reality, this module outputs data that looks like a VPC was created).\r\nterraform {\r\n  source = \"git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main\"  #  same as development\r\n}\r\n\r\n# Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.\r\ninclude \"root\" {\r\n  path = find_in_parent_folders()\r\n}\r\n\r\n# This module expects no inputs, but most will expect at least a few. This is how I input those values.\r\ninputs = {\r\n  cidr_block = \"10.223.0.0/18\"  #  different from development\r\n  nat_gw_count = 1  #  same as development\r\n}\r\n```\r\n\r\nSome values will be the same between `development` and `staging`, like `nat_gw_count = 1`. However, most values passed into Terraform modules are not unique to the environment. Therefore, we can keep this common configuration in a different HCL file and reference it from all of our `terragrunt.hcl` files that deploy Terraform modules.\r\n\r\nTo start the `_envcommon` pattern in this example, we will create a new HCL file at this location, `_envcommon/services/demo-vpc.hcl`, which will hold all of our global values. We can always override the values in this file, but they are a great way to keep our infrastructure-live repository DRY:\r\n\r\n```hcl\r\n# _envcommon/services/demo-vpc.hcl\r\n\r\nterraform {\r\n  # We can override this in our terragrunt.hcl files. This is useful for promoting changes across environments.\r\n  source = \"${local.source_base_url}?ref=main\"\r\n}\r\n\r\nlocals {\r\n  source_base_url = \"git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc\"\r\n}\r\n\r\ninputs = {\r\n  # Safe default values available to all environments are defined here. They can be overridden in our terragrunt.hcl files.\r\n  cidr_block   = \"10.0.0.0/16\"\r\n  nat_gw_count = 1\r\n}\r\n```\r\n\r\n### How to use the global configuration in `_envcommon`\r\nWe can now use a very generic `terragrunt.hcl` whenever we need to call this `demo-vpc` in our environments:\r\n\r\n```hcl\r\n# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\r\n\r\n# Create our \"VPC.\" In reality, this module outputs data that looks like a VPC was created).\r\nterraform {\r\n  source = \"${include.envcommon.locals.source_base_url}?ref=main\"\r\n}\r\n\r\n# Follow the _envcommon pattern and use the configuration located at _envcommon/services/demo-vpc.hcl\r\ninclude \"envcommon\" {\r\n  path = \"${dirname(find_in_parent_folders())}/_envcommon/services/demo-vpc.hcl\"\r\n  # We want to reference the variables from the included config in this configuration, so we expose it.\r\n  expose = true\r\n}\r\n\r\n# Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.\r\ninclude \"root\" {\r\n  path = find_in_parent_folders()\r\n}\r\n\r\ninputs = {\r\n  cidr_block = \"10.222.0.0/18\"  # Unique only to development, so we override the default _envcommon value of 10.0.0.0/16.\r\n}\r\n```\r\n### Using prior art to maximize `_envcommon` DRYness for new modules\r\nYour Reference Architecture was deployed with several dozen modules. A good one to look at would be `_envcommon/data-stores/redis.hcl` to see `dependency` blocks. The purpose of `dependency` blocks is to extract values from other modules' existing infrastructure that your new module depends on, e.g., your Redis cluster needs a VPC to run in, and the Redis module expects a value for `vpc_id`.\r\n\r\n```hcl\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n# Dependencies are modules that need to be deployed before this one.\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\ndependency \"vpc\" {\r\n  config_path = \"${get_terragrunt_dir()}/../../networking/vpc\"\r\n\r\n  mock_outputs = {\r\n    // ...\r\n  }\r\n  mock_outputs_allowed_terraform_commands = [\"validate\", ]\r\n}\r\n\r\ndependency \"network_bastion\" {\r\n  config_path = \"${get_terragrunt_dir()}/../../networking/openvpn-server\"\r\n  // ...\r\n```\r\n\r\nMany AWS resources depend on a VPC, and many Terraform modules expect a value for `vpc_id` to ensure the resources are deployed to the correct network location. We can be very DRY here. Rather than hardcoding the `vpc_id` in a `.tfvars` file or doing a [remote_state](https://registry.terraform.io/providers/hashicorp/terraform/latest/docs/data-sources/remote_state) data call, we can use the filesystem and directory structure to access values output from other modules using `config_path = // ..`.\r\n\r\nWe access the `dependency` address space to pass values into our `inputs = {}` for the Terraform module we want to deploy. In this example, there are many safe default values like `instance_type = \"cache.t3.micro\"` to ensure we don't accidentally launch an expensive instance type, but we also use values from _three_ different Terraform modules that the Redis depends on:\r\n\r\n```hcl\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n# MODULE PARAMETERS\r\n# These are the variables we must pass in to use the module specified in the terragrunt configuration above.\r\n# This defines the parameters that are common across all environments.\r\n# ---------------------------------------------------------------------------------------------------------------------\r\ninputs = {\r\n  # Redis cluster name must be < 40 characters\r\n  name = substr(\"redis-${local.name_prefix}-${lower(local.account_name)}\", 0, 40)\r\n\r\n  instance_type = \"cache.t3.micro\"\r\n  vpc_id        = dependency.vpc.outputs.vpc_id\r\n  subnet_ids    = dependency.vpc.outputs.private_persistence_subnet_ids\r\n  redis_version = \"5.0.6\"\r\n\r\n  replication_group_size    = 1\r\n  enable_multi_az           = false\r\n  enable_automatic_failover = false\r\n  parameter_group_name      = \"default.redis5.0\"\r\n  enable_cloudwatch_alarms  = true\r\n  alarms_sns_topic_arns     = [dependency.sns.outputs.topic_arn]\r\n\r\n  # Here we allow any connection from the private app subnet tier of the VPC. You can further restrict network access by\r\n  # security groups for better defense in depth.\r\n  allow_connections_from_cidr_blocks     = dependency.vpc.outputs.private_app_subnet_cidr_blocks\r\n  allow_connections_from_security_groups = [dependency.network_bastion.outputs.security_group_id]\r\n\r\n  # Only apply changes during the scheduled maintenance window, as certain DB changes cause degraded performance or\r\n  # downtime. For more info, see: https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/Clusters.Modify.html\r\n  # We default to false, but in non-prod environments we set it to true to immediately roll out the changes.\r\n  apply_immediately = false\r\n}\r\n```\r\n\r\nAt the bottom of `_envcommon/data-stores/redis.hcl` we can see those dependencies in action:\r\n```hcl\r\ninputs = {\r\n  // ...\r\n  vpc_id        = dependency.vpc.outputs.vpc_id\r\n  subnet_ids    = dependency.vpc.outputs.private_persistence_subnet_ids\r\n\r\n  // ...\r\n  alarms_sns_topic_arns     = [dependency.sns.outputs.topic_arn]\r\n\r\n  // ...\r\n  allow_connections_from_cidr_blocks     = dependency.vpc.outputs.private_app_subnet_cidr_blocks\r\n  allow_connections_from_security_groups = [dependency.network_bastion.outputs.security_group_id]\r\n\r\n}\r\n```\r\n\r\n### Wrapping up\r\nWe have successfully made our configuration DRY in the following areas:\r\n- Terraform state\r\n- Terraform providers\r\n- Common Terraform module configuration\r\n- Passing of outputs from one module to the inputs of another module\r\n\r\nAnd additionally, because of Terragrunt, we've unlocked additional benefits:\r\n- Created a path for developers to copy-paste `terragrunt.hcl` files with safe defaults to self-serve infrastructure.\r\n- Used GitOps to create new infrastructure.\r\n- Created a pattern to merge different versions of the same module into different environments.\r\n\r\n","bodyHTML":"<h2 dir=\"auto\">Deploy a new module in the Reference Architecture</h2>\n<p dir=\"auto\">There are several ways you can accomplish this. I'll start from the most basic form, then extend that basic structure to be fully <a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\" rel=\"nofollow\">\"DRY\"</a> by following the <code class=\"notranslate\">_envcommon</code> pattern used here at Gruntwork.</p>\n<h3 dir=\"auto\">TL;DR</h3>\n<p dir=\"auto\">We must create a new <code class=\"notranslate\">terragrunt.hcl</code> file that points to the location of the Terraform module we want to deploy. This new Terragrunt file will live in its own directory, separate from the other modules inside your Reference Architecture's repository.</p>\n<blockquote>\n<p dir=\"auto\">üìç Writing and updating the <code class=\"notranslate\">infrastructure-live</code> codebase is the only work that should be done on your local machine; the deployment happens through GitOps and a serverless CI/CD architecture called <strong>Gruntwork Pipelines</strong> that was built for you as part of the Reference Architecture deployment.</p>\n</blockquote>\n<p dir=\"auto\"><strong><em>Where</em></strong> we create this new directory matters. The filesystem path dictates where in AWS the infrastructure will be deployed, e.g., <code class=\"notranslate\">development/us-east-2/development/services/eks-cluster/terragrunt.hcl</code> will look up the EKS Terraform module and then deploy it in:</p>\n<ul dir=\"auto\">\n<li>The <code class=\"notranslate\">development</code> AWS account\n<ul dir=\"auto\">\n<li>In the <code class=\"notranslate\">us-east-2</code> AWS region\n<ul dir=\"auto\">\n<li>Into the <code class=\"notranslate\">app</code> VPC created during the initial Reference Architecture deployment, which is represented by the second <code class=\"notranslate\">development</code> directory in the full module path.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p dir=\"auto\">üåü There are actually two VPCs in each AWS account when the Reference Architecture is initially deployed; <code class=\"notranslate\">app</code>, where the sample app runs, and <code class=\"notranslate\">mgmt</code>, which runs Gruntwork Pipelines. The code for both lives inside your <code class=\"notranslate\">infrastructure-live</code> repository, and the latter is represented by something like <code class=\"notranslate\">development/us-east-2/mgmt/networking/vpc</code>.</p>\n</blockquote>\n<p dir=\"auto\">Since each deployed <em>instance</em> of Terraform module will have its own directory, you should give meaningful names to them like <code class=\"notranslate\">payments-eks-cluster</code> or <code class=\"notranslate\">risk-mgmt-aurora-database</code> that will be used across all environments, e.g., the <code class=\"notranslate\">data-team-ecs</code> module be called three times, once for each environment, so it will exist in:</p>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">prod/us-west-2/data-team-ecs</code></li>\n<li><code class=\"notranslate\">stage/us-west-2/data-team-ecs</code></li>\n<li><code class=\"notranslate\">dev/us-east-2/data-team-ecs</code></li>\n</ul>\n<p dir=\"auto\">Once you've created your module directory and <code class=\"notranslate\">terragrunt.hcl</code>, you can open up a pull request with your changes, merge it, and Gruntwork Pipelines will <strong><em>automatically deploy</em></strong> your Terraform module into the correct account and region.</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# Create a directory and file in your Reference Architecture, something like:\n# development/us-east-2/development/services/demo-eks-cluster/terragrunt.hcl\n\n# Define the Terraform module you want to deploy\nterraform {\n  source = &quot;git@example.com:example-org/your-modules-here.git//modules/eks-cluster?ref=v0.0.1&quot;\n}\n\n# Include the `terragrunt.hcl` located in the root of our Reference Architecture's\n# repository because this file contains all the templating required to make our\n# Terraform state and AWS provider DRY.\ninclude &quot;root&quot; {\n  path = find_in_parent_folders()\n}\n\n# Your module will expect some inputs. This is how to pass in values for those inputs:\ninputs = {\n  name   = &quot;development-eks-cluster&quot;\n  vpc_id = &quot;vpc-85556dc&quot;\n}\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> Create a directory and file in your Reference Architecture, something like:<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> development/us-east-2/development/services/demo-eks-cluster/terragrunt.hcl<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Define the Terraform module you want to deploy<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">terraform</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git@example.com:example-org/your-modules-here.git//modules/eks-cluster?ref=v0.0.1<span class=\"pl-pds\">\"</span></span>\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Include the `terragrunt.hcl` located in the root of our Reference Architecture's<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> repository because this file contains all the templating required to make our<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Terraform state and AWS provider DRY.<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">include</span> <span class=\"pl-smi\">\"root\"</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">path</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-c1\">find_in_parent_folders</span>()\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Your module will expect some inputs. This is how to pass in values for those inputs:<span class=\"pl-c\"></span></span>\n<span class=\"pl-v\"><span class=\"pl-smi\">inputs</span> <span class=\"pl-k\">=</span> </span>{\n  name   <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>development-eks-cluster<span class=\"pl-pds\">\"</span></span>\n  vpc_id <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>vpc-85556dc<span class=\"pl-pds\">\"</span></span>\n}</pre></div>\n<blockquote>\n<p dir=\"auto\"><g-emoji class=\"g-emoji\" alias=\"warning\">‚ö†Ô∏è</g-emoji> This is <strong>not DRY</strong>, as we'd end up with duplicate code across environments. How to DRY up this code using Terragrunt and the <code class=\"notranslate\">_envcommon</code> pattern is explained in the following guide.</p>\n</blockquote>\n<h3 dir=\"auto\">Background</h3>\n<p dir=\"auto\">If we want to follow the already deployed modules' pattern, we'll first need a new directory and a <code class=\"notranslate\">terragrunt.hcl</code> file. The directory name should be meaningful. For example, suppose we had a <code class=\"notranslate\">development</code> environment with five different ECS clusters. In that case, we'd need a directory for each ECS cluster, as those folders contain the <code class=\"notranslate\">terragrunt.hcl</code> file that calls the Terraform module to create them. So it would look something like this:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"development/us-east-2/development/services 0 $ tree\n.\n‚îú‚îÄ‚îÄ team-a-ecs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\n‚îú‚îÄ‚îÄ team-b-ecs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\n‚îú‚îÄ‚îÄ team-c-ecs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\n‚îú‚îÄ‚îÄ team-d-ecs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\n‚îî‚îÄ‚îÄ team-e-ecs\n    ‚îî‚îÄ‚îÄ terragrunt.hcl\"><pre class=\"notranslate\"><code class=\"notranslate\">development/us-east-2/development/services 0 $ tree\n.\n‚îú‚îÄ‚îÄ team-a-ecs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\n‚îú‚îÄ‚îÄ team-b-ecs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\n‚îú‚îÄ‚îÄ team-c-ecs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\n‚îú‚îÄ‚îÄ team-d-ecs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ terragrunt.hcl\n‚îî‚îÄ‚îÄ team-e-ecs\n    ‚îî‚îÄ‚îÄ terragrunt.hcl\n</code></pre></div>\n<p dir=\"auto\">Each of those <code class=\"notranslate\">terragrunt.hcl</code> files would look something like this:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# development/us-east-2/development/services/team-e-ecs/terragrunt.hcl\n\n# This is where we tell Terragrunt what Terraform module we want to deploy.\nterraform {\n  source = &quot;git@example.com:gruntwork-io/terraform-aws-service-catalog.git//modules/services/ecs-cluster?ref=v0.0.1&quot;\n}\n\n# This is where we provide the input values to the Terraform module we want to deploy.\ninputs = {\n  cluster_name          = &quot;Team E&quot;\n  cluster_instance_type = &quot;t2.micro&quot;\n}\n\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> development/us-east-2/development/services/team-e-ecs/terragrunt.hcl<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> This is where we tell Terragrunt what Terraform module we want to deploy.<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">terraform</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git@example.com:gruntwork-io/terraform-aws-service-catalog.git//modules/services/ecs-cluster?ref=v0.0.1<span class=\"pl-pds\">\"</span></span>\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> This is where we provide the input values to the Terraform module we want to deploy.<span class=\"pl-c\"></span></span>\n<span class=\"pl-v\"><span class=\"pl-smi\">inputs</span> <span class=\"pl-k\">=</span> </span>{\n  cluster_name          <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Team E<span class=\"pl-pds\">\"</span></span>\n  cluster_instance_type <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>t2.micro<span class=\"pl-pds\">\"</span></span>\n}\n</pre></div>\n<h3 dir=\"auto\">How to add a module using a new <code class=\"notranslate\">terragrunt.hcl</code> file</h3>\n<p dir=\"auto\">In my case, I will add a <code class=\"notranslate\">demo-vpc</code> directory with a <code class=\"notranslate\">terragrunt.hcl</code> file that deploys an elementary module to my existing Reference Architecture. The first step would be creating my directory and Terragrunt file:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"mkdir development/us-east-2/development/services/demo-vpc\"><pre class=\"notranslate\"><code class=\"notranslate\">mkdir development/us-east-2/development/services/demo-vpc\n</code></pre></div>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"cd development/us-east-2/development/services/demo-vpc &amp;&amp; touch terragrunt.hcl\"><pre class=\"notranslate\"><code class=\"notranslate\">cd development/us-east-2/development/services/demo-vpc &amp;&amp; touch terragrunt.hcl\n</code></pre></div>\n<p dir=\"auto\">Since my <a href=\"https://github.com/gruntwork-io/terraform-fake-modules/tree/main/modules/aws/vpc\">demo module</a> doesn't expect any inputs, I <em>could</em> quickly (<strong>but don't)</strong> get started by only having this one block in my <code class=\"notranslate\">terragrunt.hcl</code> file:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\n\nterraform {\n  source = &quot;git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main&quot;\n}\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> development/us-east-2/development/services/demo-vpc/terragrunt.hcl<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-en\">terraform</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main<span class=\"pl-pds\">\"</span></span>\n}</pre></div>\n<p dir=\"auto\">And it <em>will</em> run just fine, but can you <strong>spot the bug</strong> üêû in our thinking?</p>\n<blockquote>\n<p dir=\"auto\">‚è∞ <strong>Hint:</strong> Consider the lack of Terraform configuration in our <code class=\"notranslate\">terragrunt.hcl</code> file and remember Terragrunt is a <em>thin</em> wrapper for Terraform, not a replacement, and does not remove the need for fundamental concepts like providers and state.</p>\n</blockquote>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/101607944/221265019-a2608768-6ed4-4e17-9aca-a0081ef3c315.png\"><img src=\"https://user-images.githubusercontent.com/101607944/221265019-a2608768-6ed4-4e17-9aca-a0081ef3c315.png\" alt=\"Screen Shot 2023-02-24 at 1 44 35 PM\" style=\"max-width: 100%;\"></a></p>\n<h3 dir=\"auto\"><g-emoji class=\"g-emoji\" alias=\"warning\">‚ö†Ô∏è</g-emoji> The issue with the above Terragrunt configuration (and not being <em>DRY</em> enough)</h3>\n<p dir=\"auto\">If we run this job, everything will be created as expected, but if we re-run this job, it will create <strong>duplicate resources</strong>. This is bad for a number of reasons; not only will we have duplicate infrastructure that could potentially spin up and overload other services, but we also cannot quickly and cleanly destroy the duplicate infrastructure that's been created. What we need to do is define a <strong><a href=\"https://developer.hashicorp.com/terraform/language/state\" rel=\"nofollow\">Terraform state</a></strong> to keep track of all the infrastructure that has come in and out of service. If our Terraform configuration was set up correctly, instead of recreating these resources, it would detect they already exist and that there are no configuration changes, so the deployment will do <a href=\"https://en.wikipedia.org/wiki/NOP_(code)\" rel=\"nofollow\">nothing</a>. Let's understand what happened with this example and then remediate it in the following sections.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/101607944/221267080-620fc27c-4cc2-45d3-bff4-4c68d9a8429f.png\"><img src=\"https://user-images.githubusercontent.com/101607944/221267080-620fc27c-4cc2-45d3-bff4-4c68d9a8429f.png\" alt=\"Screen Shot 2023-02-24 at 1 51 16 PM\" style=\"max-width: 100%;\"></a></p>\n<h3 dir=\"auto\">So what happened when we re-ran our deployment, and how do we fix it?</h3>\n<p dir=\"auto\">We didn't define an S3 backend to store our Terraform state in. This behavior occurs because Gruntwork Pipelines uses serverless runners on ECS for the actual deployment. When we did the first <code class=\"notranslate\">apply</code>, the state was stored locally. However, that runner was spun down, and that local state was lost. The second <code class=\"notranslate\">apply</code> recreated those resources, unaware of previous CI/CD jobs. The Gruntwork Pipelines <a href=\"https://docs.gruntwork.io/guides/build-it-yourself/pipelines/core-concepts/threat-model-of-ci-cd/\" rel=\"nofollow\">architecture</a> has many benefits but requires following best practices. Using a remote Terraform state is a major one of those best practices we enforce, but we also follow a pattern (described below) to make it painless to manage at scale.</p>\n<blockquote>\n<p dir=\"auto\">üìç No matter what you use for CI/CD, always use a remote backend for your Terraform state!</p>\n</blockquote>\n<p dir=\"auto\">In our <code class=\"notranslate\">demo-vpc/terragrunt.hcl</code> file above, we got away with a lot, like Gruntwork Pipelines finding a default AWS provider automatically, but we can do better than that.</p>\n<p dir=\"auto\">To solve this, we <em>could</em> <strong>(but don't)</strong> modify our <code class=\"notranslate\">demo-vpc/terragrunt.hcl</code> to look something like this:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\n\nterraform {\n  source = &quot;git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main&quot;\n}\n\n# Non-DRY example, do not use!\n remote_state {\n    backend = &quot;s3&quot;\n    config = {\n      bucket = &quot;mybucket&quot;\n      key    = &quot;path/to/my/key&quot;\n      region = &quot;us-east-1&quot;\n    }\n  }\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> development/us-east-2/development/services/demo-vpc/terragrunt.hcl<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-en\">terraform</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main<span class=\"pl-pds\">\"</span></span>\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Non-DRY example, do not use!<span class=\"pl-c\"></span></span>\n <span class=\"pl-en\">remote_state</span> {\n    <span class=\"pl-v\"><span class=\"pl-smi\">backend</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>s3<span class=\"pl-pds\">\"</span></span>\n    <span class=\"pl-v\"><span class=\"pl-smi\">config</span> <span class=\"pl-k\">=</span> </span>{\n      bucket <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>mybucket<span class=\"pl-pds\">\"</span></span>\n      key    <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>path/to/my/key<span class=\"pl-pds\">\"</span></span>\n      region <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>us-east-1<span class=\"pl-pds\">\"</span></span>\n    }\n  }</pre></div>\n<p dir=\"auto\">But if we had thousands of resources to manage, defining that <code class=\"notranslate\">remote_state</code> block for every Terraform module we use would become burdensome and dangerous.</p>\n<h3 dir=\"auto\">üçè Managing our Terraform state using DRY principals</h3>\n<p dir=\"auto\">In the <strong>root</strong> of our <code class=\"notranslate\">infrastructure-live</code> repository that contains our Reference Architecture, there is a <code class=\"notranslate\">terragrunt.hcl</code> file.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/101607944/221269844-bec58a96-c5b0-4629-bb16-4d635745e054.png\"><img src=\"https://user-images.githubusercontent.com/101607944/221269844-bec58a96-c5b0-4629-bb16-4d635745e054.png\" alt=\"Screen Shot 2023-02-24 at 2 08 26 PM\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">Inside this file, you'll see a block of HCL that looks like this:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# ----------------------------------------------------------------------------------------------------------------\n# GENERATED REMOTE STATE BLOCK\n# ----------------------------------------------------------------------------------------------------------------\n# Generate the Terraform remote state block for storing state in S3\nremote_state {\n  backend = &quot;s3&quot;\n  config = {\n    encrypt                   = true\n    bucket                    = lower(&quot;${local.name_prefix}-${local.account_name}-${local.aws_region}-tf-state&quot;)\n    key                       = &quot;${path_relative_to_include()}/terraform.tfstate&quot;\n    // ...\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> ----------------------------------------------------------------------------------------------------------------<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> GENERATED REMOTE STATE BLOCK<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> ----------------------------------------------------------------------------------------------------------------<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Generate the Terraform remote state block for storing state in S3<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">remote_state</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">backend</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>s3<span class=\"pl-pds\">\"</span></span>\n  <span class=\"pl-v\"><span class=\"pl-smi\">config</span> <span class=\"pl-k\">=</span> </span>{\n    encrypt                   <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>\n    bucket                    <span class=\"pl-k\">=</span> <span class=\"pl-c1\">lower</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-k\">${</span><span class=\"pl-smi\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">name_prefix</span><span class=\"pl-k\">}</span>-<span class=\"pl-k\">${</span><span class=\"pl-smi\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">account_name</span><span class=\"pl-k\">}</span>-<span class=\"pl-k\">${</span><span class=\"pl-smi\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">aws_region</span><span class=\"pl-k\">}</span>-tf-state<span class=\"pl-pds\">\"</span></span>)\n    key                       <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-k\">${</span><span class=\"pl-c1\">path_relative_to_include</span>()<span class=\"pl-k\">}</span>/terraform.tfstate<span class=\"pl-pds\">\"</span></span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> ...<span class=\"pl-c\"></span></span></pre></div>\n<blockquote>\n<p dir=\"auto\">üÜí Note that the only <strong>hardcoded value</strong> is <code class=\"notranslate\">encrypt = true</code>, which is desirable for this use case, but the rest are parameterized strings used to automatically gather environment context and use that to define values for things like the <code class=\"notranslate\">bucket</code> name and <code class=\"notranslate\">terraform.tfstate</code> location inside S3. Pretty cool, but how do we use it?</p>\n</blockquote>\n<h3 dir=\"auto\">Not repeating ourselves</h3>\n<p dir=\"auto\">To access this generated remote state block that will automatically take care of everything for us, we need to <em>include</em> the <strong>root <code class=\"notranslate\">terragrunt.hcl</code></strong> into our <code class=\"notranslate\">demo-vpc/terragrunt.hcl</code> by doing the following:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\n\n# Create our &quot;VPC.&quot; In reality, this module outputs data that looks like a VPC was created).\nterraform {\n  source = &quot;git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main&quot;\n}\n\n# Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.\ninclude &quot;root&quot; {\n  path = find_in_parent_folders()\n}\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> development/us-east-2/development/services/demo-vpc/terragrunt.hcl<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Create our \"VPC.\" In reality, this module outputs data that looks like a VPC was created).<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">terraform</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main<span class=\"pl-pds\">\"</span></span>\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">include</span> <span class=\"pl-smi\">\"root\"</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">path</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-c1\">find_in_parent_folders</span>()\n}</pre></div>\n<h3 dir=\"auto\">Adding inputs before deploying our module</h3>\n<p dir=\"auto\">This part is straightforward. Even though my module doesn't expect any inputs, I will add some since 99% of modules out there expect some value.</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\n\n# Create our &quot;VPC.&quot; In reality, this module outputs data that looks like a VPC was created).\nterraform {\n  source = &quot;git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main&quot;\n}\n\n# Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.\ninclude &quot;root&quot; {\n  path = find_in_parent_folders()\n}\n\n# This module expects no inputs, but most will expect at least a few. This is how I input those values.\ninputs = {\n  cidr_block = &quot;10.222.0.0/18&quot;\n  nat_gw_count = 1\n}\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> development/us-east-2/development/services/demo-vpc/terragrunt.hcl<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Create our \"VPC.\" In reality, this module outputs data that looks like a VPC was created).<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">terraform</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main<span class=\"pl-pds\">\"</span></span>\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">include</span> <span class=\"pl-smi\">\"root\"</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">path</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-c1\">find_in_parent_folders</span>()\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> This module expects no inputs, but most will expect at least a few. This is how I input those values.<span class=\"pl-c\"></span></span>\n<span class=\"pl-v\"><span class=\"pl-smi\">inputs</span> <span class=\"pl-k\">=</span> </span>{\n  cidr_block <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>10.222.0.0/18<span class=\"pl-pds\">\"</span></span>\n  nat_gw_count <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span>\n}</pre></div>\n<h3 dir=\"auto\">Merging and what to expect</h3>\n<p dir=\"auto\">Open up a pull request with your new <code class=\"notranslate\">terragrunt.hcl</code> file and module directory, review the <code class=\"notranslate\">terragrunt plan</code> output, approve it, and hit merge. Gruntwork Pipelines will <strong>deploy it in the correct environment automatically</strong> üü¢ . Nothing should be run from a local workstation.</p>\n<p dir=\"auto\">Suppose this is the first time you're deploying your specific Terraform module. In that case, Terragrunt will automatically create the remote state for you based on the above changes we made to <code class=\"notranslate\">demo-vpc/terragrunt.hcl</code> by including the root <code class=\"notranslate\">terragrunt.hcl</code> that contains all of the generated remote state information. The scripts that initialize Gruntwork Pipelines and use <code class=\"notranslate\">git-updated-folders</code> to understand what environments have changed are in the <code class=\"notranslate\">_ci</code> directory.</p>\n<p dir=\"auto\">If we look in S3, we'll see that a brand new <code class=\"notranslate\">terraform.tfstate</code> file in a brand new location that matches our location in the repository, <code class=\"notranslate\">development/us-east-2/development/services/demo-vpc/terragrunt.hcl</code>, in a bucket that matches <code class=\"notranslate\">lower(\"${local.name_prefix}-${local.account_name}-${local.aws_region}-tf-state\")</code>.<br>\n<a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/101607944/221279954-367508c6-8d6f-4564-bc86-481dc9e8d48c.png\"><img src=\"https://user-images.githubusercontent.com/101607944/221279954-367508c6-8d6f-4564-bc86-481dc9e8d48c.png\" alt=\"Screen Shot 2023-02-24 at 2 30 28 PM\" style=\"max-width: 100%;\"></a></p>\n<h2 dir=\"auto\">Create global configurations in <code class=\"notranslate\">_envcommon</code> to be DRY</h2>\n<p dir=\"auto\">We have now made the Terraform state and AWS provider information DRY, but If we wanted to launch our <code class=\"notranslate\">demo-vpc</code> in the <code class=\"notranslate\">staging</code> environment? The most obvious answer is to do something like this:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# staging/us-east-2/staging/services/demo-vpc/terragrunt.hcl\n\n# Create our &quot;VPC.&quot; In reality, this module outputs data that looks like a VPC was created).\nterraform {\n  source = &quot;git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main&quot;  #  same as development\n}\n\n# Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.\ninclude &quot;root&quot; {\n  path = find_in_parent_folders()\n}\n\n# This module expects no inputs, but most will expect at least a few. This is how I input those values.\ninputs = {\n  cidr_block = &quot;10.223.0.0/18&quot;  #  different from development\n  nat_gw_count = 1  #  same as development\n}\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> staging/us-east-2/staging/services/demo-vpc/terragrunt.hcl<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Create our \"VPC.\" In reality, this module outputs data that looks like a VPC was created).<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">terraform</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc?ref=main<span class=\"pl-pds\">\"</span></span>  <span class=\"pl-c\"><span class=\"pl-c\">#</span>  same as development<span class=\"pl-c\"></span></span>\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">include</span> <span class=\"pl-smi\">\"root\"</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">path</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-c1\">find_in_parent_folders</span>()\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> This module expects no inputs, but most will expect at least a few. This is how I input those values.<span class=\"pl-c\"></span></span>\n<span class=\"pl-v\"><span class=\"pl-smi\">inputs</span> <span class=\"pl-k\">=</span> </span>{\n  cidr_block <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>10.223.0.0/18<span class=\"pl-pds\">\"</span></span>  <span class=\"pl-c\"><span class=\"pl-c\">#</span>  different from development<span class=\"pl-c\"></span></span>\n  nat_gw_count <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span>  <span class=\"pl-c\"><span class=\"pl-c\">#</span>  same as development<span class=\"pl-c\"></span></span>\n}</pre></div>\n<p dir=\"auto\">Some values will be the same between <code class=\"notranslate\">development</code> and <code class=\"notranslate\">staging</code>, like <code class=\"notranslate\">nat_gw_count = 1</code>. However, most values passed into Terraform modules are not unique to the environment. Therefore, we can keep this common configuration in a different HCL file and reference it from all of our <code class=\"notranslate\">terragrunt.hcl</code> files that deploy Terraform modules.</p>\n<p dir=\"auto\">To start the <code class=\"notranslate\">_envcommon</code> pattern in this example, we will create a new HCL file at this location, <code class=\"notranslate\">_envcommon/services/demo-vpc.hcl</code>, which will hold all of our global values. We can always override the values in this file, but they are a great way to keep our infrastructure-live repository DRY:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# _envcommon/services/demo-vpc.hcl\n\nterraform {\n  # We can override this in our terragrunt.hcl files. This is useful for promoting changes across environments.\n  source = &quot;${local.source_base_url}?ref=main&quot;\n}\n\nlocals {\n  source_base_url = &quot;git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc&quot;\n}\n\ninputs = {\n  # Safe default values available to all environments are defined here. They can be overridden in our terragrunt.hcl files.\n  cidr_block   = &quot;10.0.0.0/16&quot;\n  nat_gw_count = 1\n}\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> _envcommon/services/demo-vpc.hcl<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-en\">terraform</span> {\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> We can override this in our terragrunt.hcl files. This is useful for promoting changes across environments.<span class=\"pl-c\"></span></span>\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-k\">${</span><span class=\"pl-smi\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">source_base_url</span><span class=\"pl-k\">}</span>?ref=main<span class=\"pl-pds\">\"</span></span>\n}\n\n<span class=\"pl-en\">locals</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">source_base_url</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git@github.com:gruntwork-io/terraform-fake-modules.git//modules/aws/vpc<span class=\"pl-pds\">\"</span></span>\n}\n\n<span class=\"pl-v\"><span class=\"pl-smi\">inputs</span> <span class=\"pl-k\">=</span> </span>{\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> Safe default values available to all environments are defined here. They can be overridden in our terragrunt.hcl files.<span class=\"pl-c\"></span></span>\n  cidr_block   <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>10.0.0.0/16<span class=\"pl-pds\">\"</span></span>\n  nat_gw_count <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span>\n}</pre></div>\n<h3 dir=\"auto\">How to use the global configuration in <code class=\"notranslate\">_envcommon</code></h3>\n<p dir=\"auto\">We can now use a very generic <code class=\"notranslate\">terragrunt.hcl</code> whenever we need to call this <code class=\"notranslate\">demo-vpc</code> in our environments:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# development/us-east-2/development/services/demo-vpc/terragrunt.hcl\n\n# Create our &quot;VPC.&quot; In reality, this module outputs data that looks like a VPC was created).\nterraform {\n  source = &quot;${include.envcommon.locals.source_base_url}?ref=main&quot;\n}\n\n# Follow the _envcommon pattern and use the configuration located at _envcommon/services/demo-vpc.hcl\ninclude &quot;envcommon&quot; {\n  path = &quot;${dirname(find_in_parent_folders())}/_envcommon/services/demo-vpc.hcl&quot;\n  # We want to reference the variables from the included config in this configuration, so we expose it.\n  expose = true\n}\n\n# Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.\ninclude &quot;root&quot; {\n  path = find_in_parent_folders()\n}\n\ninputs = {\n  cidr_block = &quot;10.222.0.0/18&quot;  # Unique only to development, so we override the default _envcommon value of 10.0.0.0/16.\n}\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> development/us-east-2/development/services/demo-vpc/terragrunt.hcl<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Create our \"VPC.\" In reality, this module outputs data that looks like a VPC was created).<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">terraform</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">source</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-k\">${</span><span class=\"pl-smi\">include</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">envcommon</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">locals</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">source_base_url</span><span class=\"pl-k\">}</span>?ref=main<span class=\"pl-pds\">\"</span></span>\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Follow the _envcommon pattern and use the configuration located at _envcommon/services/demo-vpc.hcl<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">include</span> <span class=\"pl-smi\">\"envcommon\"</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">path</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-k\">${</span><span class=\"pl-c1\">dirname</span>(<span class=\"pl-c1\">find_in_parent_folders</span>())<span class=\"pl-k\">}</span>/_envcommon/services/demo-vpc.hcl<span class=\"pl-pds\">\"</span></span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> We want to reference the variables from the included config in this configuration, so we expose it.<span class=\"pl-c\"></span></span>\n  <span class=\"pl-v\"><span class=\"pl-smi\">expose</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-c1\">true</span>\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Include the root `terragrunt.hcl` because this file contains all our Terraform state and AWS provider information.<span class=\"pl-c\"></span></span>\n<span class=\"pl-en\">include</span> <span class=\"pl-smi\">\"root\"</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">path</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-c1\">find_in_parent_folders</span>()\n}\n\n<span class=\"pl-v\"><span class=\"pl-smi\">inputs</span> <span class=\"pl-k\">=</span> </span>{\n  cidr_block <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>10.222.0.0/18<span class=\"pl-pds\">\"</span></span>  <span class=\"pl-c\"><span class=\"pl-c\">#</span> Unique only to development, so we override the default _envcommon value of 10.0.0.0/16.<span class=\"pl-c\"></span></span>\n}</pre></div>\n<h3 dir=\"auto\">Using prior art to maximize <code class=\"notranslate\">_envcommon</code> DRYness for new modules</h3>\n<p dir=\"auto\">Your Reference Architecture was deployed with several dozen modules. A good one to look at would be <code class=\"notranslate\">_envcommon/data-stores/redis.hcl</code> to see <code class=\"notranslate\">dependency</code> blocks. The purpose of <code class=\"notranslate\">dependency</code> blocks is to extract values from other modules' existing infrastructure that your new module depends on, e.g., your Redis cluster needs a VPC to run in, and the Redis module expects a value for <code class=\"notranslate\">vpc_id</code>.</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# ---------------------------------------------------------------------------------------------------------------------\n# Dependencies are modules that need to be deployed before this one.\n# ---------------------------------------------------------------------------------------------------------------------\n\ndependency &quot;vpc&quot; {\n  config_path = &quot;${get_terragrunt_dir()}/../../networking/vpc&quot;\n\n  mock_outputs = {\n    // ...\n  }\n  mock_outputs_allowed_terraform_commands = [&quot;validate&quot;, ]\n}\n\ndependency &quot;network_bastion&quot; {\n  config_path = &quot;${get_terragrunt_dir()}/../../networking/openvpn-server&quot;\n  // ...\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> ---------------------------------------------------------------------------------------------------------------------<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Dependencies are modules that need to be deployed before this one.<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> ---------------------------------------------------------------------------------------------------------------------<span class=\"pl-c\"></span></span>\n\n<span class=\"pl-en\">dependency</span> <span class=\"pl-smi\">\"vpc\"</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">config_path</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-k\">${</span><span class=\"pl-c1\">get_terragrunt_dir</span>()<span class=\"pl-k\">}</span>/../../networking/vpc<span class=\"pl-pds\">\"</span></span>\n\n  <span class=\"pl-v\"><span class=\"pl-smi\">mock_outputs</span> <span class=\"pl-k\">=</span> </span>{\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> ...<span class=\"pl-c\"></span></span>\n  }\n  <span class=\"pl-v\"><span class=\"pl-smi\">mock_outputs_allowed_terraform_commands</span> <span class=\"pl-k\">=</span> </span>[<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>validate<span class=\"pl-pds\">\"</span></span>, ]\n}\n\n<span class=\"pl-en\">dependency</span> <span class=\"pl-smi\">\"network_bastion\"</span> {\n  <span class=\"pl-v\"><span class=\"pl-smi\">config_path</span> <span class=\"pl-k\">=</span> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-k\">${</span><span class=\"pl-c1\">get_terragrunt_dir</span>()<span class=\"pl-k\">}</span>/../../networking/openvpn-server<span class=\"pl-pds\">\"</span></span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> ...<span class=\"pl-c\"></span></span></pre></div>\n<p dir=\"auto\">Many AWS resources depend on a VPC, and many Terraform modules expect a value for <code class=\"notranslate\">vpc_id</code> to ensure the resources are deployed to the correct network location. We can be very DRY here. Rather than hardcoding the <code class=\"notranslate\">vpc_id</code> in a <code class=\"notranslate\">.tfvars</code> file or doing a <a href=\"https://registry.terraform.io/providers/hashicorp/terraform/latest/docs/data-sources/remote_state\" rel=\"nofollow\">remote_state</a> data call, we can use the filesystem and directory structure to access values output from other modules using <code class=\"notranslate\">config_path = // ..</code>.</p>\n<p dir=\"auto\">We access the <code class=\"notranslate\">dependency</code> address space to pass values into our <code class=\"notranslate\">inputs = {}</code> for the Terraform module we want to deploy. In this example, there are many safe default values like <code class=\"notranslate\">instance_type = \"cache.t3.micro\"</code> to ensure we don't accidentally launch an expensive instance type, but we also use values from <em>three</em> different Terraform modules that the Redis depends on:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"# ---------------------------------------------------------------------------------------------------------------------\n# MODULE PARAMETERS\n# These are the variables we must pass in to use the module specified in the terragrunt configuration above.\n# This defines the parameters that are common across all environments.\n# ---------------------------------------------------------------------------------------------------------------------\ninputs = {\n  # Redis cluster name must be &lt; 40 characters\n  name = substr(&quot;redis-${local.name_prefix}-${lower(local.account_name)}&quot;, 0, 40)\n\n  instance_type = &quot;cache.t3.micro&quot;\n  vpc_id        = dependency.vpc.outputs.vpc_id\n  subnet_ids    = dependency.vpc.outputs.private_persistence_subnet_ids\n  redis_version = &quot;5.0.6&quot;\n\n  replication_group_size    = 1\n  enable_multi_az           = false\n  enable_automatic_failover = false\n  parameter_group_name      = &quot;default.redis5.0&quot;\n  enable_cloudwatch_alarms  = true\n  alarms_sns_topic_arns     = [dependency.sns.outputs.topic_arn]\n\n  # Here we allow any connection from the private app subnet tier of the VPC. You can further restrict network access by\n  # security groups for better defense in depth.\n  allow_connections_from_cidr_blocks     = dependency.vpc.outputs.private_app_subnet_cidr_blocks\n  allow_connections_from_security_groups = [dependency.network_bastion.outputs.security_group_id]\n\n  # Only apply changes during the scheduled maintenance window, as certain DB changes cause degraded performance or\n  # downtime. For more info, see: https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/Clusters.Modify.html\n  # We default to false, but in non-prod environments we set it to true to immediately roll out the changes.\n  apply_immediately = false\n}\"><pre class=\"notranslate\"><span class=\"pl-c\"><span class=\"pl-c\">#</span> ---------------------------------------------------------------------------------------------------------------------<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> MODULE PARAMETERS<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> These are the variables we must pass in to use the module specified in the terragrunt configuration above.<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> This defines the parameters that are common across all environments.<span class=\"pl-c\"></span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> ---------------------------------------------------------------------------------------------------------------------<span class=\"pl-c\"></span></span>\n<span class=\"pl-v\"><span class=\"pl-smi\">inputs</span> <span class=\"pl-k\">=</span> </span>{\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> Redis cluster name must be &lt; 40 characters<span class=\"pl-c\"></span></span>\n  name <span class=\"pl-k\">=</span> <span class=\"pl-c1\">substr</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>redis-<span class=\"pl-k\">${</span><span class=\"pl-smi\">local</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">name_prefix</span><span class=\"pl-k\">}</span>-<span class=\"pl-k\">${</span><span class=\"pl-c1\">lower</span>(local<span class=\"pl-k\">.</span><span class=\"pl-smi\">account_name</span>)<span class=\"pl-k\">}</span><span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">40</span>)\n\n  instance_type <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>cache.t3.micro<span class=\"pl-pds\">\"</span></span>\n  vpc_id        <span class=\"pl-k\">=</span> dependency.vpc.outputs.vpc_id\n  subnet_ids    <span class=\"pl-k\">=</span> dependency.vpc.outputs.private_persistence_subnet_ids\n  redis_version <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>5.0.6<span class=\"pl-pds\">\"</span></span>\n\n  replication_group_size    <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span>\n  enable_multi_az           <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>\n  enable_automatic_failover <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>\n  parameter_group_name      <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>default.redis5.0<span class=\"pl-pds\">\"</span></span>\n  enable_cloudwatch_alarms  <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>\n  alarms_sns_topic_arns     <span class=\"pl-k\">=</span> [dependency.sns.outputs.topic_arn]\n\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> Here we allow any connection from the private app subnet tier of the VPC. You can further restrict network access by<span class=\"pl-c\"></span></span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> security groups for better defense in depth.<span class=\"pl-c\"></span></span>\n  allow_connections_from_cidr_blocks     <span class=\"pl-k\">=</span> dependency.vpc.outputs.private_app_subnet_cidr_blocks\n  allow_connections_from_security_groups <span class=\"pl-k\">=</span> [dependency.network_bastion.outputs.security_group_id]\n\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> Only apply changes during the scheduled maintenance window, as certain DB changes cause degraded performance or<span class=\"pl-c\"></span></span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> downtime. For more info, see: https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/Clusters.Modify.html<span class=\"pl-c\"></span></span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> We default to false, but in non-prod environments we set it to true to immediately roll out the changes.<span class=\"pl-c\"></span></span>\n  apply_immediately <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>\n}</pre></div>\n<p dir=\"auto\">At the bottom of <code class=\"notranslate\">_envcommon/data-stores/redis.hcl</code> we can see those dependencies in action:</p>\n<div class=\"highlight highlight-source-hcl notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"inputs = {\n  // ...\n  vpc_id        = dependency.vpc.outputs.vpc_id\n  subnet_ids    = dependency.vpc.outputs.private_persistence_subnet_ids\n\n  // ...\n  alarms_sns_topic_arns     = [dependency.sns.outputs.topic_arn]\n\n  // ...\n  allow_connections_from_cidr_blocks     = dependency.vpc.outputs.private_app_subnet_cidr_blocks\n  allow_connections_from_security_groups = [dependency.network_bastion.outputs.security_group_id]\n\n}\"><pre class=\"notranslate\"><span class=\"pl-v\"><span class=\"pl-smi\">inputs</span> <span class=\"pl-k\">=</span> </span>{\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> ...<span class=\"pl-c\"></span></span>\n  vpc_id        <span class=\"pl-k\">=</span> dependency.vpc.outputs.vpc_id\n  subnet_ids    <span class=\"pl-k\">=</span> dependency.vpc.outputs.private_persistence_subnet_ids\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> ...<span class=\"pl-c\"></span></span>\n  alarms_sns_topic_arns     <span class=\"pl-k\">=</span> [dependency.sns.outputs.topic_arn]\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> ...<span class=\"pl-c\"></span></span>\n  allow_connections_from_cidr_blocks     <span class=\"pl-k\">=</span> dependency.vpc.outputs.private_app_subnet_cidr_blocks\n  allow_connections_from_security_groups <span class=\"pl-k\">=</span> [dependency.network_bastion.outputs.security_group_id]\n\n}</pre></div>\n<h3 dir=\"auto\">Wrapping up</h3>\n<p dir=\"auto\">We have successfully made our configuration DRY in the following areas:</p>\n<ul dir=\"auto\">\n<li>Terraform state</li>\n<li>Terraform providers</li>\n<li>Common Terraform module configuration</li>\n<li>Passing of outputs from one module to the inputs of another module</li>\n</ul>\n<p dir=\"auto\">And additionally, because of Terragrunt, we've unlocked additional benefits:</p>\n<ul dir=\"auto\">\n<li>Created a path for developers to copy-paste <code class=\"notranslate\">terragrunt.hcl</code> files with safe defaults to self-serve infrastructure.</li>\n<li>Used GitOps to create new infrastructure.</li>\n<li>Created a pattern to merge different versions of the same module into different environments.</li>\n</ul>"}}} />

</CenterLayout>
  

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "4d52cf66ff44da02d44f87678c9f3695"
}
##DOCS-SOURCER-END -->
