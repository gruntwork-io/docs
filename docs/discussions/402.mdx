---
hide_table_of_contents: true
hide_title: true
custom_edit_url: null
---

import CenterLayout from "/src/components/CenterLayout"
import GitHub from "/src/components/GitHub"

<CenterLayout>
<span class="title">Knowledge Base</span>
<h1>Terragrunt architecture best practices?</h1>
<GitHub json={{"id":"D_kwDOF8slf84APcua","number":402,"author":{"login":"yorinasub17"},"title":"Terragrunt architecture best practices?","body":"I’m getting started with Terragrunt and want to make sure I have this conceptually right. It looks like we can only source a single module from, e.g. `my-app/terragrunt.hcl`. So if my app needs, say, an ASG, a security group, and a load balancer, I might create `modules/my-app/` and source 3 modules from there. Is that right?\r\n\r\nHaving the `terragrunt.hcl` reference a fairly specific module that references 3 other re-usable modules seems a bit odd to me, so I’m not sure I’m thinking about this right. Especially since we’re using Gruntwork modules, so each of those three re-usable modules is really a wrapper for a Gruntwork module. The chain of nested modules seems to get long pretty quickly.","bodyHTML":"<p dir=\"auto\">I’m getting started with Terragrunt and want to make sure I have this conceptually right. It looks like we can only source a single module from, e.g. <code class=\"notranslate\">my-app/terragrunt.hcl</code>. So if my app needs, say, an ASG, a security group, and a load balancer, I might create <code class=\"notranslate\">modules/my-app/</code> and source 3 modules from there. Is that right?</p>\n<p dir=\"auto\">Having the <code class=\"notranslate\">terragrunt.hcl</code> reference a fairly specific module that references 3 other re-usable modules seems a bit odd to me, so I’m not sure I’m thinking about this right. Especially since we’re using Gruntwork modules, so each of those three re-usable modules is really a wrapper for a Gruntwork module. The chain of nested modules seems to get long pretty quickly.</p>","answer":{"body":"The core of Terragrunt architecture is considering how you want to break apart the Terraform state. While Terraform is optimized for working with a single state file, Terragrunt supports breaking apart your Terraform state into multiple component infrastructure through it's many features like `dependency`.\r\n\r\nHowever, since Terragrunt ultimately relies on Terraform under the hood, it is limited by Terraform's ability to have a single root module, and that's why you still need to define a single Terraform module to act as the root module for Terragrunt to invoke at the folder level.\r\n\r\nThe way we at Gruntwork think about this is to differentiate between Services and Modules (See our [blog post on Modules, Services, and Architectures](https://blog.gruntwork.io/introducing-the-gruntwork-module-service-and-architecture-catalogs-eb3a21b99f70) for more details). The Service module is an opinionated, specific way to deploy components that fit the needs of your organization, which is less reusable, but is designed to be directly deployed by Terragrunt. If you look at our Service module for the ASG ([asg-service](https://github.com/gruntwork-io/terraform-aws-service-catalog/tree/master/modules/services/asg-service)), you will see that it combines the Gruntwork modules to construct the deployable ASG unit.\r\n\r\nGiven that, you should be striving for 2 links in your chain: Services and Modules. That is, when extending Gruntwork modules, it is oftentimes much better organizationally to extend them in the Service layer by combining Gruntwork modules with resources and modules to create the deployable unit, rather than extending Gruntwork modules to create more Modules. This should significantly help with the dependency management.","bodyHTML":"<p dir=\"auto\">The core of Terragrunt architecture is considering how you want to break apart the Terraform state. While Terraform is optimized for working with a single state file, Terragrunt supports breaking apart your Terraform state into multiple component infrastructure through it's many features like <code class=\"notranslate\">dependency</code>.</p>\n<p dir=\"auto\">However, since Terragrunt ultimately relies on Terraform under the hood, it is limited by Terraform's ability to have a single root module, and that's why you still need to define a single Terraform module to act as the root module for Terragrunt to invoke at the folder level.</p>\n<p dir=\"auto\">The way we at Gruntwork think about this is to differentiate between Services and Modules (See our <a href=\"https://blog.gruntwork.io/introducing-the-gruntwork-module-service-and-architecture-catalogs-eb3a21b99f70\" rel=\"nofollow\">blog post on Modules, Services, and Architectures</a> for more details). The Service module is an opinionated, specific way to deploy components that fit the needs of your organization, which is less reusable, but is designed to be directly deployed by Terragrunt. If you look at our Service module for the ASG (<a href=\"https://github.com/gruntwork-io/terraform-aws-service-catalog/tree/master/modules/services/asg-service\">asg-service</a>), you will see that it combines the Gruntwork modules to construct the deployable ASG unit.</p>\n<p dir=\"auto\">Given that, you should be striving for 2 links in your chain: Services and Modules. That is, when extending Gruntwork modules, it is oftentimes much better organizationally to extend them in the Service layer by combining Gruntwork modules with resources and modules to create the deployable unit, rather than extending Gruntwork modules to create more Modules. This should significantly help with the dependency management.</p>"},"comments":{"edges":[{"node":{"author":{"login":"yorinasub17"},"body":"The core of Terragrunt architecture is considering how you want to break apart the Terraform state. While Terraform is optimized for working with a single state file, Terragrunt supports breaking apart your Terraform state into multiple component infrastructure through it's many features like `dependency`.\r\n\r\nHowever, since Terragrunt ultimately relies on Terraform under the hood, it is limited by Terraform's ability to have a single root module, and that's why you still need to define a single Terraform module to act as the root module for Terragrunt to invoke at the folder level.\r\n\r\nThe way we at Gruntwork think about this is to differentiate between Services and Modules (See our [blog post on Modules, Services, and Architectures](https://blog.gruntwork.io/introducing-the-gruntwork-module-service-and-architecture-catalogs-eb3a21b99f70) for more details). The Service module is an opinionated, specific way to deploy components that fit the needs of your organization, which is less reusable, but is designed to be directly deployed by Terragrunt. If you look at our Service module for the ASG ([asg-service](https://github.com/gruntwork-io/terraform-aws-service-catalog/tree/master/modules/services/asg-service)), you will see that it combines the Gruntwork modules to construct the deployable ASG unit.\r\n\r\nGiven that, you should be striving for 2 links in your chain: Services and Modules. That is, when extending Gruntwork modules, it is oftentimes much better organizationally to extend them in the Service layer by combining Gruntwork modules with resources and modules to create the deployable unit, rather than extending Gruntwork modules to create more Modules. This should significantly help with the dependency management."}},{"node":{"author":{"login":"yorinasub17"},"body":"A side note:\r\n\r\nWhen thinking about what should go in the Services, you should also be thinking about the Terraform state file. In essence, each Service Terraform module will translate to a single Terraform state. Given that, it is oftentimes useful to think about splitting your Services based on how you want to split the Terraform state. I previously wrote about this in [a Terragrunt issue](https://github.com/gruntwork-io/terragrunt/issues/1514), which I will copy here since it is still relevant:\r\n\r\nWhen it comes to componentization, the best thing that has worked for us is to base it on the reason why you want to break up your state file in the first place. In general, there are 3 key benefits to breaking up your state file:\r\n\r\n- **Performance**: You keep your modules and deployments smaller, so `plan` and `apply` can run faster per iteration. You can also apply the changes across multiple workers, increasing parallelism and concurrency of deployments.\r\n- **Reliability**: By isolating and componentizing your changes, you run less risk of having a larger blast radius and having unintended consequences. In a world where a small typo could end up destroying things, having the ability to limit the actions is huge in keeping your infrastructure safe.\r\n- **Security**: You may not want all your developers to have access to touch everything. Breaking up state files allows you to set up fine grained ACLs to split up the permissions needed to do a deployment.\r\n\r\nOn the other hand, breaking up state files adds a lot of complexity to the dependency management, and you lose the benefits of [having reliable planning mechanisms](https://github.com/gruntwork-io/terragrunt/issues/720#issuecomment-497888756). So you don't want to break it down too much.\r\n\r\nGiven that, the following litmus test has worked well for us when it comes to breaking things up:\r\n\r\n- **How long does it take to deploy your changes?** A big fat terraform module might take 10-15 minutes just to run `plan`. This might be ok for something that is deployed infrequently (e.g., once per year), but could add up to a lot of wasted time if it is done multiple times per day. You may want to break that up so that you can deploy in parallel across multiple workers (since only one process can touch the state file at a time).\r\n\r\n- **How often does the infrastructure change?** For example, you might deploy your application and service multiple times per day, touch your kubernetes cluster (like make node adjustments) a few times per month, and update your network architecture once per year. So it is natural to break up your components in to `application`, `eks`, and `vpc`, since the deploy frequency is very different.\r\n\r\n- **What level of granularity do you need for ACLs?** For large organization, you may want only a small subset of trusted developers to access the full stack of the infrastructure. You may even have tiers, where only a handful has access to IAM, some have access to VPC and eks, but everyone has access to k8s services. Breaking up the state file and managing the ACLs via s3 bucket policies can provide this fine grained access control."}}]}}} />

</CenterLayout>
  

<!-- ##DOCS-SOURCER-START
{
  "sourcePlugin": "github-discussions",
  "hash": "d749b742be14ea670e836e60cf42b8f4"
}
##DOCS-SOURCER-END -->
